(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{479:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/react/index.js\nvar react = __webpack_require__(0);\nvar react_default = /*#__PURE__*/__webpack_require__.n(react);\n\n// EXTERNAL MODULE: ./node_modules/cabana-react/build/index.js\nvar build = __webpack_require__(4);\n\n// EXTERNAL MODULE: ./node_modules/@mdx-js/tag/dist/index.js\nvar dist = __webpack_require__(212);\n\n// EXTERNAL MODULE: ./node_modules/cabanaico/dist-es5/index.js\nvar dist_es5 = __webpack_require__(17);\n\n// CONCATENATED MODULE: ./src/docs/Button.mdx\nfunction _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\n\nvar primaryProps = {\n  bg: \'primary\',\n  color: \'white\',\n  mr: 1\n};\n\nvar Button_MDXContent =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inherits(MDXContent, _React$Component);\n\n  function MDXContent(props) {\n    var _this;\n\n    _classCallCheck(this, MDXContent);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(MDXContent).call(this, props));\n    _this.layout = null;\n    return _this;\n  }\n\n  _createClass(MDXContent, [{\n    key: "render",\n    value: function render() {\n      var _this$props = this.props,\n          components = _this$props.components,\n          props = _objectWithoutProperties(_this$props, ["components"]);\n\n      return react_default.a.createElement(dist["MDXTag"], {\n        name: "wrapper",\n        components: components\n      }, react_default.a.createElement(dist["MDXTag"], {\n        name: "p",\n        components: components\n      }, react_default.a.createElement("a", {\n        id: "Buttons"\n      })), react_default.a.createElement(dist["MDXTag"], {\n        name: "h1",\n        components: components\n      }, "Buttons"), react_default.a.createElement(dist["MDXTag"], {\n        name: "h2",\n        components: components\n      }, "Small"), react_default.a.createElement(build["ButtonSmall"], primaryProps, "Button"), react_default.a.createElement(build["ButtonSmall"], primaryProps, react_default.a.createElement(dist_es5["IconHeart"], null), " Button"), react_default.a.createElement(build["ButtonSmall"], primaryProps, "Button ", react_default.a.createElement(dist_es5["IconHeart"], null)), react_default.a.createElement(dist["MDXTag"], {\n        name: "h2",\n        components: components\n      }, "Normal"), react_default.a.createElement(build["Button"], primaryProps, "Button"), react_default.a.createElement(build["Button"], primaryProps, react_default.a.createElement(dist_es5["IconHeart"], null), " Button"), react_default.a.createElement(build["Button"], primaryProps, "Button ", react_default.a.createElement(dist_es5["IconHeart"], null)), react_default.a.createElement(dist["MDXTag"], {\n        name: "h2",\n        components: components\n      }, "Large"), react_default.a.createElement(build["ButtonLarge"], _extends({}, primaryProps, {\n        fontWeight: "bold"\n      }), "Button"), react_default.a.createElement(build["ButtonLarge"], _extends({}, primaryProps, {\n        fontWeight: "bold"\n      }), react_default.a.createElement(dist_es5["IconHeart"], null), " Button"), react_default.a.createElement(build["ButtonLarge"], _extends({}, primaryProps, {\n        fontWeight: "bold"\n      }), "Button ", react_default.a.createElement(dist_es5["IconHeart"], null)), react_default.a.createElement(dist["MDXTag"], {\n        name: "h2",\n        components: components\n      }, "Colourful"), react_default.a.createElement(build["ButtonSmall"], {\n        bg: "error",\n        borderRadius: "large",\n        color: "white"\n      }, "Button"), react_default.a.createElement(build["Button"], {\n        bg: "success",\n        color: "error"\n      }, react_default.a.createElement(dist_es5["IconHeart"], null), " Button"), react_default.a.createElement(build["ButtonLarge"], {\n        bg: "tertiary",\n        color: "warning"\n      }, react_default.a.createElement(dist_es5["IconHeart"], null), " Button"));\n    }\n  }]);\n\n  return MDXContent;\n}(react_default.a.Component);\n\n\n// CONCATENATED MODULE: ./src/docs/Card.mdx\nfunction Card_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Card_typeof = function _typeof(obj) { return typeof obj; }; } else { Card_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Card_typeof(obj); }\n\nfunction Card_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Card_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Card_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction Card_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Card_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Card_createClass(Constructor, protoProps, staticProps) { if (protoProps) Card_defineProperties(Constructor.prototype, protoProps); if (staticProps) Card_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction Card_possibleConstructorReturn(self, call) { if (call && (Card_typeof(call) === "object" || typeof call === "function")) { return call; } return Card_assertThisInitialized(self); }\n\nfunction Card_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction Card_getPrototypeOf(o) { Card_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Card_getPrototypeOf(o); }\n\nfunction Card_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Card_setPrototypeOf(subClass, superClass); }\n\nfunction Card_setPrototypeOf(o, p) { Card_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Card_setPrototypeOf(o, p); }\n\n\n\n\n\nvar SampleBodyText = "Hey there! I\'m Tom. A singer, who\'s well known for my various awesome jams, and other amazing thangs.";\n\nvar Card_MDXContent =\n/*#__PURE__*/\nfunction (_React$Component) {\n  Card_inherits(MDXContent, _React$Component);\n\n  function MDXContent(props) {\n    var _this;\n\n    Card_classCallCheck(this, MDXContent);\n\n    _this = Card_possibleConstructorReturn(this, Card_getPrototypeOf(MDXContent).call(this, props));\n    _this.layout = null;\n    return _this;\n  }\n\n  Card_createClass(MDXContent, [{\n    key: "render",\n    value: function render() {\n      var _this$props = this.props,\n          components = _this$props.components,\n          props = Card_objectWithoutProperties(_this$props, ["components"]);\n\n      return react_default.a.createElement(dist["MDXTag"], {\n        name: "wrapper",\n        components: components\n      }, react_default.a.createElement(dist["MDXTag"], {\n        name: "p",\n        components: components\n      }, react_default.a.createElement("a", {\n        id: "Cards"\n      })), react_default.a.createElement(dist["MDXTag"], {\n        name: "h1",\n        components: components\n      }, "Cards"), react_default.a.createElement("div", {\n        style: {\n          maxWidth: 1024,\n          display: \'grid\',\n          gridTemplateColumns: \'1fr 1fr 1fr\',\n          gridColumnGap: 10,\n          gridRowGap: 30,\n          alignItems: \'start\'\n        }\n      }, react_default.a.createElement(build["Card"], {\n        is: "article",\n        textAlign: "center"\n      }, react_default.a.createElement(build["CardImage"], null), react_default.a.createElement(build["CardTitle"], null, "Tom Jones"), react_default.a.createElement(build["CardBodyText"], {\n        mb: 4,\n        display: "inline-block"\n      }, SampleBodyText), react_default.a.createElement(build["Button"], {\n        bg: "primary",\n        color: "white",\n        borderRadius: "large"\n      }, react_default.a.createElement(dist_es5["IconHeart"], null), "Follow me on Twitter")), react_default.a.createElement(build["Card"], {\n        is: "article",\n        textAlign: "center"\n      }, react_default.a.createElement(build["CardImage"], {\n        height: "240px"\n      }), react_default.a.createElement(build["CardTitle"], null, "Tom Jones"), react_default.a.createElement(build["CardBodyText"], {\n        mb: 4,\n        display: "inline-block"\n      }, SampleBodyText), react_default.a.createElement(build["Button"], {\n        bg: "primary",\n        color: "white"\n      }, "View Full Profile")), react_default.a.createElement(build["Card"], {\n        is: "article"\n      }, react_default.a.createElement(build["CardImage"], null), react_default.a.createElement(build["CardTitle"], null, "Tom Jones"), react_default.a.createElement(build["CardBodyText"], null, SampleBodyText), react_default.a.createElement(build["CardFooter"], null, react_default.a.createElement(build["TinyText"], {\n        color: "grey"\n      }, "23 Friends"))), react_default.a.createElement(build["Card"], {\n        is: "article",\n        p: 8\n      }, react_default.a.createElement(build["CardTitle"], null, "More Padding"), react_default.a.createElement(build["CardBodyText"], null, SampleBodyText)), react_default.a.createElement(build["Card"], {\n        is: "article",\n        bg: "secondary",\n        borderRadius: "small",\n        boxShadow: 60\n      }, react_default.a.createElement(build["CardTitle"], {\n        color: "warning",\n        fontWeight: "normal"\n      }, "Fancy secondary one"), react_default.a.createElement(build["CardBodyText"], {\n        color: "white"\n      }, " ", SampleBodyText)), react_default.a.createElement(build["Card"], {\n        is: "article",\n        borderRadius: "small",\n        boxShadow: 60\n      }, react_default.a.createElement(build["CardTitle"], {\n        color: "success",\n        fontWeight: "normal",\n        mb: 0\n      }, "Success!"))));\n    }\n  }]);\n\n  return MDXContent;\n}(react_default.a.Component);\n\n\n// CONCATENATED MODULE: ./src/docs/Forms/Checkbox.js\nfunction Checkbox_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Checkbox_typeof = function _typeof(obj) { return typeof obj; }; } else { Checkbox_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Checkbox_typeof(obj); }\n\nfunction Checkbox_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Checkbox_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Checkbox_createClass(Constructor, protoProps, staticProps) { if (protoProps) Checkbox_defineProperties(Constructor.prototype, protoProps); if (staticProps) Checkbox_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction Checkbox_possibleConstructorReturn(self, call) { if (call && (Checkbox_typeof(call) === "object" || typeof call === "function")) { return call; } return Checkbox_assertThisInitialized(self); }\n\nfunction Checkbox_getPrototypeOf(o) { Checkbox_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Checkbox_getPrototypeOf(o); }\n\nfunction Checkbox_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Checkbox_setPrototypeOf(subClass, superClass); }\n\nfunction Checkbox_setPrototypeOf(o, p) { Checkbox_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Checkbox_setPrototypeOf(o, p); }\n\nfunction Checkbox_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\n\n\n\nvar Checkbox_StatefulCheckbox =\n/*#__PURE__*/\nfunction (_React$Component) {\n  Checkbox_inherits(StatefulCheckbox, _React$Component);\n\n  function StatefulCheckbox() {\n    var _this;\n\n    Checkbox_classCallCheck(this, StatefulCheckbox);\n\n    _this = Checkbox_possibleConstructorReturn(this, Checkbox_getPrototypeOf(StatefulCheckbox).call(this));\n    _this.state = {\n      checked: false\n    };\n    _this.handleChange = _this.handleChange.bind(Checkbox_assertThisInitialized(Checkbox_assertThisInitialized(_this)));\n    return _this;\n  }\n\n  Checkbox_createClass(StatefulCheckbox, [{\n    key: "handleChange",\n    value: function handleChange() {\n      this.setState({\n        checked: !this.state.checked\n      });\n    }\n  }, {\n    key: "render",\n    value: function render() {\n      var _this$props = this.props,\n          label = _this$props.label,\n          value = _this$props.value,\n          disabled = _this$props.disabled;\n      return react_default.a.createElement(build["Checkbox"], {\n        disabled: disabled,\n        value: value,\n        label: label,\n        checked: this.state.checked,\n        onChange: this.handleChange,\n        py: 1\n      });\n    }\n  }]);\n\n  return StatefulCheckbox;\n}(react_default.a.Component);\n\nvar Checkbox_Checkboxes = function Checkboxes() {\n  return react_default.a.createElement(build["Box"], {\n    display: "grid",\n    style: {\n      gridTemplateColumns: \'1fr\',\n      alignItems: \'center\'\n    }\n  }, react_default.a.createElement(Checkbox_StatefulCheckbox, {\n    value: "jar_jar",\n    label: "Jar Jar Binks"\n  }), react_default.a.createElement(Checkbox_StatefulCheckbox, {\n    value: "queen_amidala",\n    label: "Queen Amidala"\n  }), react_default.a.createElement(Checkbox_StatefulCheckbox, {\n    disabled: true,\n    value: "mon_mothma",\n    label: "Mon Mothma"\n  }));\n};\n\n/* harmony default export */ var Checkbox = (Checkbox_Checkboxes);\n// CONCATENATED MODULE: ./src/docs/Forms/Radio.js\nfunction Radio_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Radio_typeof = function _typeof(obj) { return typeof obj; }; } else { Radio_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Radio_typeof(obj); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Radio_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Radio_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Radio_createClass(Constructor, protoProps, staticProps) { if (protoProps) Radio_defineProperties(Constructor.prototype, protoProps); if (staticProps) Radio_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction Radio_possibleConstructorReturn(self, call) { if (call && (Radio_typeof(call) === "object" || typeof call === "function")) { return call; } return Radio_assertThisInitialized(self); }\n\nfunction Radio_getPrototypeOf(o) { Radio_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Radio_getPrototypeOf(o); }\n\nfunction Radio_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Radio_setPrototypeOf(subClass, superClass); }\n\nfunction Radio_setPrototypeOf(o, p) { Radio_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Radio_setPrototypeOf(o, p); }\n\nfunction Radio_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\n\n\n\nvar Radio_StatefulRadioButtons =\n/*#__PURE__*/\nfunction (_React$Component) {\n  Radio_inherits(StatefulRadioButtons, _React$Component);\n\n  function StatefulRadioButtons() {\n    var _this;\n\n    Radio_classCallCheck(this, StatefulRadioButtons);\n\n    _this = Radio_possibleConstructorReturn(this, Radio_getPrototypeOf(StatefulRadioButtons).call(this));\n    _this.state = {\n      selected: \'anakin_skywalker\'\n    };\n    _this.handleChange = _this.handleChange.bind(Radio_assertThisInitialized(Radio_assertThisInitialized(_this)));\n    return _this;\n  }\n\n  Radio_createClass(StatefulRadioButtons, [{\n    key: "handleChange",\n    value: function handleChange(event) {\n      this.setState({\n        selected: event.target.value\n      });\n    }\n  }, {\n    key: "render",\n    value: function render() {\n      var _React$createElement;\n\n      return react_default.a.createElement(build["Box"], {\n        display: "grid",\n        style: {\n          gridTemplateColumns: \'1fr\',\n          alignItems: \'center\'\n        }\n      }, react_default.a.createElement(build["Radio"], {\n        value: "obi_wan",\n        label: "Obi Wan Kenobi",\n        checked: this.state.selected === \'obi_wan\',\n        onChange: this.handleChange,\n        py: 1\n      }), react_default.a.createElement(build["Radio"], {\n        value: "han_solo",\n        label: "Han Solo",\n        checked: this.state.selected === \'han_solo\',\n        onChange: this.handleChange,\n        py: 1\n      }), react_default.a.createElement(build["Radio"], (_React$createElement = {\n        value: "anakin_skywalker",\n        label: "Anakin Skywalker",\n        checked: true,\n        disabled: true\n      }, _defineProperty(_React$createElement, "checked", this.state.selected === \'anakin_skywalker\'), _defineProperty(_React$createElement, "onChange", this.handleChange), _defineProperty(_React$createElement, "py", 1), _React$createElement)));\n    }\n  }]);\n\n  return StatefulRadioButtons;\n}(react_default.a.Component);\n\n/* harmony default export */ var Radio = (Radio_StatefulRadioButtons);\n// CONCATENATED MODULE: ./src/docs/Forms/index.mdx\nfunction Forms_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Forms_typeof = function _typeof(obj) { return typeof obj; }; } else { Forms_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Forms_typeof(obj); }\n\nfunction Forms_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Forms_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Forms_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction Forms_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Forms_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Forms_createClass(Constructor, protoProps, staticProps) { if (protoProps) Forms_defineProperties(Constructor.prototype, protoProps); if (staticProps) Forms_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction Forms_possibleConstructorReturn(self, call) { if (call && (Forms_typeof(call) === "object" || typeof call === "function")) { return call; } return Forms_assertThisInitialized(self); }\n\nfunction Forms_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction Forms_getPrototypeOf(o) { Forms_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Forms_getPrototypeOf(o); }\n\nfunction Forms_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Forms_setPrototypeOf(subClass, superClass); }\n\nfunction Forms_setPrototypeOf(o, p) { Forms_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Forms_setPrototypeOf(o, p); }\n\n\n\n\n\n\n\nvar Forms_MDXContent =\n/*#__PURE__*/\nfunction (_React$Component) {\n  Forms_inherits(MDXContent, _React$Component);\n\n  function MDXContent(props) {\n    var _this;\n\n    Forms_classCallCheck(this, MDXContent);\n\n    _this = Forms_possibleConstructorReturn(this, Forms_getPrototypeOf(MDXContent).call(this, props));\n    _this.layout = null;\n    return _this;\n  }\n\n  Forms_createClass(MDXContent, [{\n    key: "render",\n    value: function render() {\n      var _this$props = this.props,\n          components = _this$props.components,\n          props = Forms_objectWithoutProperties(_this$props, ["components"]);\n\n      return react_default.a.createElement(dist["MDXTag"], {\n        name: "wrapper",\n        components: components\n      }, react_default.a.createElement(dist["MDXTag"], {\n        name: "p",\n        components: components\n      }, react_default.a.createElement("a", {\n        id: "Forms"\n      })), react_default.a.createElement(dist["MDXTag"], {\n        name: "h1",\n        components: components\n      }, "Forms"), react_default.a.createElement(dist["MDXTag"], {\n        name: "h2",\n        components: components\n      }, "Todo:"), react_default.a.createElement("ul", null, react_default.a.createElement("li", null, "Inputs with icons left and right"), react_default.a.createElement("li", null, "Textarea"), react_default.a.createElement("li", null, "Toggle switch")), react_default.a.createElement(build["HeadingFive"], null, "Text Inputs"), react_default.a.createElement(build["Box"], {\n        display: "grid",\n        style: {\n          gridTemplateColumns: \'1fr 1fr 1fr 1fr\',\n          gridColumnGap: 16,\n          gridRowGap: 16,\n          alignItems: \'center\'\n        }\n      }, react_default.a.createElement(build["TextInput"], {\n        placeholder: "Default"\n      }), react_default.a.createElement(build["TextInput"], {\n        borderColor: "primary",\n        placeholder: "Active"\n      }), react_default.a.createElement(build["TextInput"], {\n        borderColor: "success",\n        defaultValue: "Success"\n      }), react_default.a.createElement(build["TextInput"], {\n        borderColor: "error",\n        color: "error",\n        defaultValue: "Error"\n      }), react_default.a.createElement(build["TextInput"], {\n        borderColor: "error",\n        disabled: true\n      }), react_default.a.createElement(build["TextInput"], {\n        borderRadius: "large",\n        placeholder: "Large border radius"\n      }), react_default.a.createElement(build["TextInput"], {\n        borderRadius: "none",\n        placeholder: "No border radius"\n      }), react_default.a.createElement(build["TextInput"], {\n        borderRadius: "none"\n      }), react_default.a.createElement("div", null, react_default.a.createElement(build["FormLabel"], {\n        htmlFor: "textInput"\n      }, "First Name"), react_default.a.createElement(build["TextInput"], {\n        borderColor: "error",\n        name: "textInput"\n      }), react_default.a.createElement(build["ValidationLabel"], null, "This is a required field")), react_default.a.createElement("div", null, react_default.a.createElement(build["FormLabel"], {\n        htmlFor: "textInput2"\n      }, "Phone Number"), react_default.a.createElement(build["TextInput"], {\n        borderColor: "success",\n        name: "textInput2",\n        defaultValue: "(015) 2323 2320"\n      }), react_default.a.createElement(build["ValidationLabel"], {\n        color: "success"\n      }, "Verified"))), react_default.a.createElement(build["Box"], {\n        display: "grid",\n        style: {\n          gridTemplateColumns: \'1fr 1fr 1fr 1fr\',\n          gridColumnGap: 16,\n          gridRowGap: 16,\n          alignItems: \'center\',\n          marginTop: 32\n        }\n      }, react_default.a.createElement("div", null, react_default.a.createElement(build["HeadingFive"], null, "Radio Buttons"), react_default.a.createElement(Radio, null)), react_default.a.createElement("div", null, react_default.a.createElement(build["HeadingFive"], null, "Checkboxes"), react_default.a.createElement(Checkbox, null))));\n    }\n  }]);\n\n  return MDXContent;\n}(react_default.a.Component);\n\n\n// CONCATENATED MODULE: ./src/docs/Icon.mdx\nfunction Icon_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Icon_typeof = function _typeof(obj) { return typeof obj; }; } else { Icon_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Icon_typeof(obj); }\n\nfunction Icon_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Icon_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Icon_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction Icon_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Icon_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Icon_createClass(Constructor, protoProps, staticProps) { if (protoProps) Icon_defineProperties(Constructor.prototype, protoProps); if (staticProps) Icon_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction Icon_possibleConstructorReturn(self, call) { if (call && (Icon_typeof(call) === "object" || typeof call === "function")) { return call; } return Icon_assertThisInitialized(self); }\n\nfunction Icon_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction Icon_getPrototypeOf(o) { Icon_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Icon_getPrototypeOf(o); }\n\nfunction Icon_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Icon_setPrototypeOf(subClass, superClass); }\n\nfunction Icon_setPrototypeOf(o, p) { Icon_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Icon_setPrototypeOf(o, p); }\n\n\n\n\n\n\nvar Icon_Icons = function Icons() {\n  return react_default.a.createElement(build["Box"], {\n    fontSize: "lead",\n    display: "grid",\n    color: "darkGrey",\n    style: {\n      gridTemplateRows: \'repeat(10, 1fr)\',\n      gridTemplateColumns: \'repeat(10, 1fr)\',\n      gap: \'20px\'\n    }\n  }, Object.keys(dist_es5).map(function (key) {\n    var Icon = dist_es5[key];\n    return react_default.a.createElement(Icon, {\n      key: key\n    });\n  }));\n};\n\nvar Icon_MDXContent =\n/*#__PURE__*/\nfunction (_React$Component) {\n  Icon_inherits(MDXContent, _React$Component);\n\n  function MDXContent(props) {\n    var _this;\n\n    Icon_classCallCheck(this, MDXContent);\n\n    _this = Icon_possibleConstructorReturn(this, Icon_getPrototypeOf(MDXContent).call(this, props));\n    _this.layout = null;\n    return _this;\n  }\n\n  Icon_createClass(MDXContent, [{\n    key: "render",\n    value: function render() {\n      var _this$props = this.props,\n          components = _this$props.components,\n          props = Icon_objectWithoutProperties(_this$props, ["components"]);\n\n      return react_default.a.createElement(dist["MDXTag"], {\n        name: "wrapper",\n        components: components\n      }, react_default.a.createElement(dist["MDXTag"], {\n        name: "p",\n        components: components\n      }, react_default.a.createElement("a", {\n        id: "Icons"\n      })), react_default.a.createElement(dist["MDXTag"], {\n        name: "h1",\n        components: components\n      }, "Icons"), react_default.a.createElement(dist["MDXTag"], {\n        name: "p",\n        components: components\n      }, "Cabana uses the ", react_default.a.createElement(dist["MDXTag"], {\n        name: "a",\n        components: components,\n        parentName: "p",\n        props: {\n          "href": "https://github.com/lucastobrazil/cabanaico"\n        }\n      }, "cabanaico"), " library."), react_default.a.createElement(Icon_Icons, null));\n    }\n  }]);\n\n  return MDXContent;\n}(react_default.a.Component);\n\n\n// EXTERNAL MODULE: ./node_modules/styled-system/dist/index.esm.js + 1 modules\nvar index_esm = __webpack_require__(7);\n\n// EXTERNAL MODULE: ./node_modules/styled-components/dist/styled-components.browser.esm.js\nvar styled_components_browser_esm = __webpack_require__(5);\n\n// EXTERNAL MODULE: ./node_modules/react-router-hash-link/lib/index.js\nvar lib = __webpack_require__(213);\n\n// CONCATENATED MODULE: ./src/services/index.js\nvar makeHashLink = function makeHashLink(title) {\n  return title.split(\' \').join(\'\');\n};\n// CONCATENATED MODULE: ./src/components/DocsNav.js\nfunction _templateObject2() {\n  var data = _taggedTemplateLiteral(["\\n  list-style-type: none;\\n  ", ";\\n  ", ";\\n  ", ";\\n  ", ";\\n  a {\\n    ", ";\\n    color: inherit;\\n    text-decoration: none;\\n    display: block;\\n\\n    &:hover {\\n      color: black;\\n      background-color: rgba(0, 0, 0, 0.1);\\n    }\\n  }\\n"]);\n\n  _templateObject2 = function _templateObject2() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral(["\\n  ", ";\\n  padding: 0;\\n  ", ";\\n"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\n\n\n\n\n\n\nvar List = styled_components_browser_esm["default"].ul(_templateObject(), index_esm["fontFamily"], index_esm["space"]);\nvar ListItem = styled_components_browser_esm["default"].li(_templateObject2(), index_esm["fontWeight"], index_esm["borderBottom"], index_esm["borderColor"], index_esm["color"], index_esm["space"]);\nListItem.defaultProps = {\n  p: 1\n};\nvar items = [\'Avatars\', \'Buttons\', \'Cards\', \'Chips\', \'Forms\', \'Icons\', \'Notification Bar\', \'Pagination\', \'Progress Bar\', \'Tabs\', \'Tags\', \'Text\', \'Tooltips\'];\nvar todoItems = [\'DatePickers\', \'Dropdowns\', \'Map\', \'Menus\', \'Modal\', \'Sliders\', \'Tables\', \'Video Player\'];\nfunction DocsNav() {\n  return react_default.a.createElement(build["Box"], {\n    position: "fixed",\n    width: 246,\n    pt: 2,\n    mr: 2,\n    height: "100%",\n    css: "overflow: auto"\n  }, react_default.a.createElement(build["CaptionText"], {\n    fontWeight: "bold",\n    px: 1,\n    color: "lightGrey"\n  }, "Components"), react_default.a.createElement(List, {\n    fontFamily: "default",\n    m: 0\n  }, items.map(function (item) {\n    return react_default.a.createElement(ListItem, {\n      key: item,\n      color: "grey"\n    }, react_default.a.createElement(lib["HashLink"], {\n      to: "#".concat(makeHashLink(item))\n    }, item));\n  })), react_default.a.createElement(List, {\n    fontFamily: "default",\n    m: 0,\n    mt: 2\n  }, react_default.a.createElement(build["CaptionText"], {\n    fontWeight: "bold",\n    px: 1,\n    color: "grey"\n  }, "Not yet done:"), todoItems.map(function (item) {\n    return react_default.a.createElement(ListItem, {\n      key: item,\n      color: "grey"\n    }, react_default.a.createElement(lib["HashLink"], {\n      to: "#".concat(makeHashLink(item))\n    }, item));\n  })));\n}\n// CONCATENATED MODULE: ./src/docs/NotificationBar.mdx\nfunction NotificationBar_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { NotificationBar_typeof = function _typeof(obj) { return typeof obj; }; } else { NotificationBar_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return NotificationBar_typeof(obj); }\n\nfunction NotificationBar_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = NotificationBar_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction NotificationBar_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction NotificationBar_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction NotificationBar_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction NotificationBar_createClass(Constructor, protoProps, staticProps) { if (protoProps) NotificationBar_defineProperties(Constructor.prototype, protoProps); if (staticProps) NotificationBar_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction NotificationBar_possibleConstructorReturn(self, call) { if (call && (NotificationBar_typeof(call) === "object" || typeof call === "function")) { return call; } return NotificationBar_assertThisInitialized(self); }\n\nfunction NotificationBar_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction NotificationBar_getPrototypeOf(o) { NotificationBar_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return NotificationBar_getPrototypeOf(o); }\n\nfunction NotificationBar_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) NotificationBar_setPrototypeOf(subClass, superClass); }\n\nfunction NotificationBar_setPrototypeOf(o, p) { NotificationBar_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return NotificationBar_setPrototypeOf(o, p); }\n\n\n\n\n\nvar NotificationBar_MDXContent =\n/*#__PURE__*/\nfunction (_React$Component) {\n  NotificationBar_inherits(MDXContent, _React$Component);\n\n  function MDXContent(props) {\n    var _this;\n\n    NotificationBar_classCallCheck(this, MDXContent);\n\n    _this = NotificationBar_possibleConstructorReturn(this, NotificationBar_getPrototypeOf(MDXContent).call(this, props));\n    _this.layout = null;\n    return _this;\n  }\n\n  NotificationBar_createClass(MDXContent, [{\n    key: "render",\n    value: function render() {\n      var _this$props = this.props,\n          components = _this$props.components,\n          props = NotificationBar_objectWithoutProperties(_this$props, ["components"]);\n\n      return react_default.a.createElement(dist["MDXTag"], {\n        name: "wrapper",\n        components: components\n      }, react_default.a.createElement(dist["MDXTag"], {\n        name: "p",\n        components: components\n      }, react_default.a.createElement("a", {\n        id: "NotificationBar"\n      })), react_default.a.createElement(dist["MDXTag"], {\n        name: "h1",\n        components: components\n      }, "NotificationBar"), react_default.a.createElement(build["NotificationBar"], {\n        mb: 1,\n        content: "Oops! There seems to be an error",\n        bg: "error",\n        color: "white"\n      }), react_default.a.createElement(build["NotificationBar"], {\n        mb: 1,\n        content: "Have you saved your work?",\n        bg: "warning",\n        color: "black"\n      }), react_default.a.createElement(build["NotificationBar"], {\n        mb: 1,\n        content: "Oh yes! Settings have been saved",\n        bg: "success",\n        color: "white"\n      }), react_default.a.createElement(build["NotificationBar"], {\n        mb: 1,\n        content: "Oh yes! Settings have been saved",\n        bg: "primary",\n        color: "white",\n        dismissable: false\n      }), react_default.a.createElement(build["NotificationBar"], {\n        boxShadow: 100,\n        m: 3,\n        icon: false,\n        fontSize: "small",\n        content: "W3Schools is optimized for learning, testing, and training. Examples might be simplified to improve reading and basic understanding. Tutorials, references, and examples are constantly reviewed to avoid errors, but we cannot warrant full correctness of all content. While using this site, you agree to have read and accepted our terms of use, cookie and privacy policy. Copyright 1999-2018 by Refsnes Data. All Rights Reserved.",\n        bg: "success",\n        color: "white"\n      }));\n    }\n  }]);\n\n  return MDXContent;\n}(react_default.a.Component);\n\n\n// CONCATENATED MODULE: ./src/docs/Pagination.mdx\nfunction Pagination_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Pagination_typeof = function _typeof(obj) { return typeof obj; }; } else { Pagination_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Pagination_typeof(obj); }\n\nfunction Pagination_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Pagination_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Pagination_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction Pagination_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Pagination_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Pagination_createClass(Constructor, protoProps, staticProps) { if (protoProps) Pagination_defineProperties(Constructor.prototype, protoProps); if (staticProps) Pagination_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction Pagination_possibleConstructorReturn(self, call) { if (call && (Pagination_typeof(call) === "object" || typeof call === "function")) { return call; } return Pagination_assertThisInitialized(self); }\n\nfunction Pagination_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction Pagination_getPrototypeOf(o) { Pagination_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Pagination_getPrototypeOf(o); }\n\nfunction Pagination_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Pagination_setPrototypeOf(subClass, superClass); }\n\nfunction Pagination_setPrototypeOf(o, p) { Pagination_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Pagination_setPrototypeOf(o, p); }\n\n\n\n\n\nvar Pagination_MDXContent =\n/*#__PURE__*/\nfunction (_React$Component) {\n  Pagination_inherits(MDXContent, _React$Component);\n\n  function MDXContent(props) {\n    var _this;\n\n    Pagination_classCallCheck(this, MDXContent);\n\n    _this = Pagination_possibleConstructorReturn(this, Pagination_getPrototypeOf(MDXContent).call(this, props));\n    _this.layout = null;\n    return _this;\n  }\n\n  Pagination_createClass(MDXContent, [{\n    key: "render",\n    value: function render() {\n      var _this$props = this.props,\n          components = _this$props.components,\n          props = Pagination_objectWithoutProperties(_this$props, ["components"]);\n\n      return react_default.a.createElement(dist["MDXTag"], {\n        name: "wrapper",\n        components: components\n      }, react_default.a.createElement(dist["MDXTag"], {\n        name: "p",\n        components: components\n      }, react_default.a.createElement("a", {\n        id: "Pagination"\n      })), react_default.a.createElement(dist["MDXTag"], {\n        name: "h1",\n        components: components\n      }, "Pagination"), react_default.a.createElement(build["Pagination"], null), react_default.a.createElement(build["Pagination"], {\n        size: 16\n      }), react_default.a.createElement(build["Pagination"], {\n        size: 32\n      }), react_default.a.createElement(build["Pagination"], {\n        type: "numbers"\n      }));\n    }\n  }]);\n\n  return MDXContent;\n}(react_default.a.Component);\n\n\n// CONCATENATED MODULE: ./src/docs/ProgressBar/helpers.js\nfunction helpers_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { helpers_typeof = function _typeof(obj) { return typeof obj; }; } else { helpers_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return helpers_typeof(obj); }\n\nfunction helpers_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction helpers_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction helpers_createClass(Constructor, protoProps, staticProps) { if (protoProps) helpers_defineProperties(Constructor.prototype, protoProps); if (staticProps) helpers_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction helpers_possibleConstructorReturn(self, call) { if (call && (helpers_typeof(call) === "object" || typeof call === "function")) { return call; } return helpers_assertThisInitialized(self); }\n\nfunction helpers_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction helpers_getPrototypeOf(o) { helpers_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return helpers_getPrototypeOf(o); }\n\nfunction helpers_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) helpers_setPrototypeOf(subClass, superClass); }\n\nfunction helpers_setPrototypeOf(o, p) { helpers_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return helpers_setPrototypeOf(o, p); }\n\n\n\n\nvar helpers_Slider = function Slider(_ref) {\n  var onChange = _ref.onChange,\n      amount = _ref.amount;\n  return react_default.a.createElement(react["Fragment"], null, react_default.a.createElement("input", {\n    type: "range",\n    style: {\n      width: \'100%\'\n    },\n    step: "1",\n    value: amount,\n    onChange: onChange,\n    list: "tickmarks"\n  }), react_default.a.createElement("datalist", {\n    id: "tickmarks"\n  }, react_default.a.createElement("option", {\n    value: "0"\n  }), react_default.a.createElement("option", {\n    value: "10"\n  }), react_default.a.createElement("option", {\n    value: "20"\n  }), react_default.a.createElement("option", {\n    value: "30"\n  }), react_default.a.createElement("option", {\n    value: "40"\n  }), react_default.a.createElement("option", {\n    value: "50"\n  }), react_default.a.createElement("option", {\n    value: "60"\n  }), react_default.a.createElement("option", {\n    value: "70"\n  }), react_default.a.createElement("option", {\n    value: "80"\n  }), react_default.a.createElement("option", {\n    value: "90"\n  }), react_default.a.createElement("option", {\n    value: "100"\n  })));\n};\n\nvar helpers_StatefulExample =\n/*#__PURE__*/\nfunction (_React$Component) {\n  helpers_inherits(StatefulExample, _React$Component);\n\n  function StatefulExample() {\n    var _this;\n\n    helpers_classCallCheck(this, StatefulExample);\n\n    _this = helpers_possibleConstructorReturn(this, helpers_getPrototypeOf(StatefulExample).call(this));\n    _this.state = {\n      amount: 62\n    };\n    return _this;\n  }\n\n  helpers_createClass(StatefulExample, [{\n    key: "onChange",\n    value: function onChange(event) {\n      this.setState({\n        amount: parseInt(event.target.value, 10)\n      });\n    }\n  }, {\n    key: "render",\n    value: function render() {\n      var amount = this.state.amount;\n      var _this$props = this.props,\n          innerBg = _this$props.innerBg,\n          outerBg = _this$props.outerBg,\n          borderRadius = _this$props.borderRadius,\n          p = _this$props.p,\n          fontSize = _this$props.fontSize,\n          showNumber = _this$props.showNumber,\n          minHeight = _this$props.minHeight,\n          color = _this$props.color;\n      return react_default.a.createElement(build["Box"], {\n        mt: 3\n      }, react_default.a.createElement(helpers_Slider, {\n        onChange: this.onChange.bind(this),\n        amount: amount\n      }), react_default.a.createElement(build["ProgressBar"], {\n        color: color,\n        p: p,\n        innerBg: innerBg,\n        outerBg: outerBg,\n        amount: amount,\n        borderRadius: borderRadius,\n        fontSize: fontSize,\n        showNumber: showNumber,\n        minHeight: minHeight\n      }));\n    }\n  }]);\n\n  return StatefulExample;\n}(react_default.a.Component);\n\n\n// CONCATENATED MODULE: ./src/docs/ProgressBar/index.mdx\nfunction ProgressBar_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { ProgressBar_typeof = function _typeof(obj) { return typeof obj; }; } else { ProgressBar_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return ProgressBar_typeof(obj); }\n\nfunction ProgressBar_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = ProgressBar_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction ProgressBar_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction ProgressBar_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction ProgressBar_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction ProgressBar_createClass(Constructor, protoProps, staticProps) { if (protoProps) ProgressBar_defineProperties(Constructor.prototype, protoProps); if (staticProps) ProgressBar_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction ProgressBar_possibleConstructorReturn(self, call) { if (call && (ProgressBar_typeof(call) === "object" || typeof call === "function")) { return call; } return ProgressBar_assertThisInitialized(self); }\n\nfunction ProgressBar_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction ProgressBar_getPrototypeOf(o) { ProgressBar_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return ProgressBar_getPrototypeOf(o); }\n\nfunction ProgressBar_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) ProgressBar_setPrototypeOf(subClass, superClass); }\n\nfunction ProgressBar_setPrototypeOf(o, p) { ProgressBar_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return ProgressBar_setPrototypeOf(o, p); }\n\n\n\n\n\n\nvar ProgressBar_MDXContent =\n/*#__PURE__*/\nfunction (_React$Component) {\n  ProgressBar_inherits(MDXContent, _React$Component);\n\n  function MDXContent(props) {\n    var _this;\n\n    ProgressBar_classCallCheck(this, MDXContent);\n\n    _this = ProgressBar_possibleConstructorReturn(this, ProgressBar_getPrototypeOf(MDXContent).call(this, props));\n    _this.layout = null;\n    return _this;\n  }\n\n  ProgressBar_createClass(MDXContent, [{\n    key: "render",\n    value: function render() {\n      var _this$props = this.props,\n          components = _this$props.components,\n          props = ProgressBar_objectWithoutProperties(_this$props, ["components"]);\n\n      return react_default.a.createElement(dist["MDXTag"], {\n        name: "wrapper",\n        components: components\n      }, react_default.a.createElement(dist["MDXTag"], {\n        name: "p",\n        components: components\n      }, react_default.a.createElement("a", {\n        id: "ProgressBar"\n      })), react_default.a.createElement(dist["MDXTag"], {\n        name: "h1",\n        components: components\n      }, "ProgressBar"), react_default.a.createElement(dist["MDXTag"], {\n        name: "p",\n        components: components\n      }, "Note: the sliders included below are to simulate the changing progress of the ", react_default.a.createElement(dist["MDXTag"], {\n        name: "inlineCode",\n        components: components,\n        parentName: "p"\n      }, "ProgressBar"), "."), react_default.a.createElement(build["Box"], {\n        width: 1 / 3\n      }, react_default.a.createElement(helpers_StatefulExample, {\n        innerBg: "primary"\n      }), react_default.a.createElement(helpers_StatefulExample, {\n        innerBg: "tertiary",\n        borderRadius: "large"\n      }), react_default.a.createElement(helpers_StatefulExample, {\n        innerBg: "success",\n        color: "white",\n        p: 1,\n        fontSize: "body",\n        borderRadius: "large"\n      }), react_default.a.createElement(helpers_StatefulExample, {\n        innerBg: "primary",\n        p: 1,\n        borderRadius: "none"\n      }), react_default.a.createElement(helpers_StatefulExample, {\n        innerBg: "primary",\n        fontSize: "uber"\n      }), react_default.a.createElement(helpers_StatefulExample, {\n        innerBg: "primary",\n        showNumber: false,\n        minHeight: 20\n      })));\n    }\n  }]);\n\n  return MDXContent;\n}(react_default.a.Component);\n\n\n// CONCATENATED MODULE: ./src/docs/Tabs.mdx\nfunction Tabs_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Tabs_typeof = function _typeof(obj) { return typeof obj; }; } else { Tabs_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Tabs_typeof(obj); }\n\nfunction Tabs_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Tabs_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Tabs_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction Tabs_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Tabs_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Tabs_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tabs_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tabs_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction Tabs_possibleConstructorReturn(self, call) { if (call && (Tabs_typeof(call) === "object" || typeof call === "function")) { return call; } return Tabs_assertThisInitialized(self); }\n\nfunction Tabs_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction Tabs_getPrototypeOf(o) { Tabs_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Tabs_getPrototypeOf(o); }\n\nfunction Tabs_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Tabs_setPrototypeOf(subClass, superClass); }\n\nfunction Tabs_setPrototypeOf(o, p) { Tabs_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Tabs_setPrototypeOf(o, p); }\n\n\n\n\n\n\nvar Tabs_MDXContent =\n/*#__PURE__*/\nfunction (_React$Component) {\n  Tabs_inherits(MDXContent, _React$Component);\n\n  function MDXContent(props) {\n    var _this;\n\n    Tabs_classCallCheck(this, MDXContent);\n\n    _this = Tabs_possibleConstructorReturn(this, Tabs_getPrototypeOf(MDXContent).call(this, props));\n    _this.layout = null;\n    return _this;\n  }\n\n  Tabs_createClass(MDXContent, [{\n    key: "render",\n    value: function render() {\n      var _this$props = this.props,\n          components = _this$props.components,\n          props = Tabs_objectWithoutProperties(_this$props, ["components"]);\n\n      return react_default.a.createElement(dist["MDXTag"], {\n        name: "wrapper",\n        components: components\n      }, react_default.a.createElement(dist["MDXTag"], {\n        name: "p",\n        components: components\n      }, react_default.a.createElement("a", {\n        id: "Tabs"\n      })), react_default.a.createElement(dist["MDXTag"], {\n        name: "h1",\n        components: components\n      }, "Tabs"), react_default.a.createElement(build["Tabs"], null, react_default.a.createElement("div", {\n        label: "News"\n      }, "See ya later, ", react_default.a.createElement("em", null, "Alligator"), "!"), react_default.a.createElement("div", {\n        label: "Store"\n      }, "After \'while, ", react_default.a.createElement("em", null, "Crocodile"), "!"), react_default.a.createElement("div", {\n        label: "Videos"\n      }, "Nothing to see here, this tab is ", react_default.a.createElement("em", null, "extinct"), "!"), react_default.a.createElement("div", {\n        label: "Photos"\n      }, "Nothing to see here, this tab is ", react_default.a.createElement("em", null, "extinct"), "!")), react_default.a.createElement(build["HeadingTwo"], {\n        fontSize: "h5",\n        mt: 6\n      }, "With Icon"), react_default.a.createElement(build["Tabs"], null, react_default.a.createElement("div", {\n        label: "Store",\n        tabIcon: react_default.a.createElement(dist_es5["IconCart"], null)\n      }, "Shopping cart!"), react_default.a.createElement("div", {\n        label: "Videos",\n        tabIcon: react_default.a.createElement(dist_es5["IconVideo"], null)\n      }, "Check out videos"), react_default.a.createElement("div", {\n        label: "Photos",\n        tabIcon: react_default.a.createElement(dist_es5["IconCamera"], null)\n      }, "See all photos")));\n    }\n  }]);\n\n  return MDXContent;\n}(react_default.a.Component);\n\n\n// CONCATENATED MODULE: ./src/docs/Text.mdx\nfunction Text_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Text_typeof = function _typeof(obj) { return typeof obj; }; } else { Text_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Text_typeof(obj); }\n\nfunction Text_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Text_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Text_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction Text_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Text_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Text_createClass(Constructor, protoProps, staticProps) { if (protoProps) Text_defineProperties(Constructor.prototype, protoProps); if (staticProps) Text_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction Text_possibleConstructorReturn(self, call) { if (call && (Text_typeof(call) === "object" || typeof call === "function")) { return call; } return Text_assertThisInitialized(self); }\n\nfunction Text_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction Text_getPrototypeOf(o) { Text_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Text_getPrototypeOf(o); }\n\nfunction Text_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Text_setPrototypeOf(subClass, superClass); }\n\nfunction Text_setPrototypeOf(o, p) { Text_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Text_setPrototypeOf(o, p); }\n\n\n\n\n\nvar Text_Content = function Content(_ref) {\n  var fontFamily = _ref.fontFamily;\n  return react_default.a.createElement("div", null, react_default.a.createElement(build["UberText"], {\n    fontWeight: "bold",\n    fontFamily: fontFamily\n  }, "Uber"), react_default.a.createElement(build["UberText"], {\n    fontFamily: fontFamily\n  }, "Uber"), react_default.a.createElement(build["HeroText"], {\n    fontWeight: "bold",\n    fontFamily: fontFamily\n  }, "Hero"), react_default.a.createElement(build["HeroText"], {\n    fontFamily: fontFamily\n  }, "Hero"), react_default.a.createElement(build["HeadingOne"], {\n    fontWeight: "bold",\n    fontFamily: fontFamily\n  }, "H1 Heading"), react_default.a.createElement(build["HeadingOne"], {\n    fontFamily: fontFamily\n  }, "H1 Heading"), react_default.a.createElement(build["HeadingTwo"], {\n    fontWeight: "bold",\n    fontFamily: fontFamily\n  }, "H2 Heading"), react_default.a.createElement(build["HeadingTwo"], {\n    fontFamily: fontFamily\n  }, "H2 Heading"), react_default.a.createElement(build["HeadingThree"], {\n    fontWeight: "bold",\n    fontFamily: fontFamily\n  }, "H3 Heading"), react_default.a.createElement(build["HeadingThree"], {\n    fontFamily: fontFamily\n  }, "H3 Heading"), react_default.a.createElement(build["HeadingFour"], {\n    fontWeight: "bold",\n    fontFamily: fontFamily\n  }, "H4 Heading"), react_default.a.createElement(build["HeadingFour"], {\n    fontFamily: fontFamily\n  }, "H4 Heading"), react_default.a.createElement(build["HeadingFive"], {\n    fontWeight: "bold",\n    fontFamily: fontFamily\n  }, "H5 Heading"), react_default.a.createElement(build["HeadingFive"], {\n    fontFamily: fontFamily\n  }, "H5 Heading"), react_default.a.createElement(build["LeadText"], {\n    fontWeight: "bold",\n    fontFamily: fontFamily\n  }, "Lead"), react_default.a.createElement(build["LeadText"], {\n    fontFamily: fontFamily\n  }, "Lead"), react_default.a.createElement(build["BodyText"], {\n    fontWeight: "bold",\n    fontFamily: fontFamily\n  }, "Body"), react_default.a.createElement(build["BodyText"], {\n    fontFamily: fontFamily\n  }, "Body"), react_default.a.createElement(build["SmallText"], {\n    fontWeight: "bold",\n    fontFamily: fontFamily\n  }, "Small"), react_default.a.createElement(build["SmallText"], {\n    fontFamily: fontFamily\n  }, "Small"), react_default.a.createElement(build["CaptionText"], {\n    fontWeight: "bold",\n    fontFamily: fontFamily\n  }, "Caption"), react_default.a.createElement(build["CaptionText"], {\n    fontFamily: fontFamily\n  }, "Caption"), react_default.a.createElement(build["TinyText"], {\n    fontWeight: "bold",\n    fontFamily: fontFamily\n  }, "Tiny"), react_default.a.createElement(build["TinyText"], {\n    fontFamily: fontFamily\n  }, "Tiny"));\n};\n\nvar Text_MDXContent =\n/*#__PURE__*/\nfunction (_React$Component) {\n  Text_inherits(MDXContent, _React$Component);\n\n  function MDXContent(props) {\n    var _this;\n\n    Text_classCallCheck(this, MDXContent);\n\n    _this = Text_possibleConstructorReturn(this, Text_getPrototypeOf(MDXContent).call(this, props));\n    _this.layout = null;\n    return _this;\n  }\n\n  Text_createClass(MDXContent, [{\n    key: "render",\n    value: function render() {\n      var _this$props = this.props,\n          components = _this$props.components,\n          props = Text_objectWithoutProperties(_this$props, ["components"]);\n\n      return react_default.a.createElement(dist["MDXTag"], {\n        name: "wrapper",\n        components: components\n      }, react_default.a.createElement(dist["MDXTag"], {\n        name: "p",\n        components: components\n      }, react_default.a.createElement("a", {\n        id: "Text"\n      })), react_default.a.createElement(dist["MDXTag"], {\n        name: "h1",\n        components: components\n      }, "Text"), react_default.a.createElement("div", {\n        style: {\n          display: \'flex\',\n          flexWrap: \'wrap\'\n        }\n      }, react_default.a.createElement("div", null, react_default.a.createElement(build["HeadingOne"], {\n        color: "secondary"\n      }, "Font Family #1"), react_default.a.createElement(Text_Content, null)), react_default.a.createElement("div", null, react_default.a.createElement(build["HeadingOne"], {\n        color: "primary"\n      }, "Font Family #2"), react_default.a.createElement(Text_Content, {\n        fontFamily: "alt"\n      }))));\n    }\n  }]);\n\n  return MDXContent;\n}(react_default.a.Component);\n\n\n// CONCATENATED MODULE: ./src/components/DocLabel.js\nfunction DocLabel_templateObject() {\n  var data = DocLabel_taggedTemplateLiteral(["\\n  color: black;\\n  ", ";\\n  display: block;\\n  text-align: center;\\n  font-size: 10px;\\n  border-radius: 3px;\\n  border: 1px solid lightgrey;\\n  text-transform: uppercase;\\n  ", ";\\n"]);\n\n  DocLabel_templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction DocLabel_taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\n\n\nvar DocLabel = styled_components_browser_esm["default"].label(DocLabel_templateObject(), index_esm["fontFamily"], index_esm["space"]);\nDocLabel.defaultProps = {\n  fontFamily: \'default\',\n  px: 1\n};\n/* harmony default export */ var components_DocLabel = (DocLabel);\n// CONCATENATED MODULE: ./src/docs/Tooltip.mdx\nfunction Tooltip_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Tooltip_typeof = function _typeof(obj) { return typeof obj; }; } else { Tooltip_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Tooltip_typeof(obj); }\n\nfunction Tooltip_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Tooltip_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Tooltip_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction Tooltip_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Tooltip_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Tooltip_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tooltip_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tooltip_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction Tooltip_possibleConstructorReturn(self, call) { if (call && (Tooltip_typeof(call) === "object" || typeof call === "function")) { return call; } return Tooltip_assertThisInitialized(self); }\n\nfunction Tooltip_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction Tooltip_getPrototypeOf(o) { Tooltip_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Tooltip_getPrototypeOf(o); }\n\nfunction Tooltip_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Tooltip_setPrototypeOf(subClass, superClass); }\n\nfunction Tooltip_setPrototypeOf(o, p) { Tooltip_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Tooltip_setPrototypeOf(o, p); }\n\nfunction Tooltip_extends() { Tooltip_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return Tooltip_extends.apply(this, arguments); }\n\n\n\n\n\nvar baseProps = {\n  fontFamily: \'default\',\n  content: \'Here is my tooltip!\',\n  bg: \'primary\',\n  color: \'papayawhip\',\n  mx: 2,\n  my: 8\n};\n\nvar Tooltip_BaseTooltip = function BaseTooltip(otherProps) {\n  return react_default.a.createElement(build["Tooltip"], Tooltip_extends({}, baseProps, otherProps));\n};\n\nvar Tooltip_MDXContent =\n/*#__PURE__*/\nfunction (_React$Component) {\n  Tooltip_inherits(MDXContent, _React$Component);\n\n  function MDXContent(props) {\n    var _this;\n\n    Tooltip_classCallCheck(this, MDXContent);\n\n    _this = Tooltip_possibleConstructorReturn(this, Tooltip_getPrototypeOf(MDXContent).call(this, props));\n    _this.layout = null;\n    return _this;\n  }\n\n  Tooltip_createClass(MDXContent, [{\n    key: "render",\n    value: function render() {\n      var _this$props = this.props,\n          components = _this$props.components,\n          props = Tooltip_objectWithoutProperties(_this$props, ["components"]);\n\n      return react_default.a.createElement(dist["MDXTag"], {\n        name: "wrapper",\n        components: components\n      }, react_default.a.createElement(dist["MDXTag"], {\n        name: "p",\n        components: components\n      }, react_default.a.createElement("a", {\n        id: "Tooltip"\n      })), react_default.a.createElement(dist["MDXTag"], {\n        name: "h1",\n        components: components\n      }, "Tooltip"), react_default.a.createElement(dist["MDXTag"], {\n        name: "p",\n        components: components\n      }, "Hover over the labels below to see the tooltips."), react_default.a.createElement(Tooltip_BaseTooltip, null, react_default.a.createElement(components_DocLabel, null, "Default")), react_default.a.createElement(Tooltip_BaseTooltip, {\n        placement: "top",\n        bg: "warning",\n        color: "secondary"\n      }, react_default.a.createElement(components_DocLabel, null, "Top")), react_default.a.createElement(Tooltip_BaseTooltip, {\n        placement: "right"\n      }, react_default.a.createElement(components_DocLabel, null, "Right")), react_default.a.createElement(Tooltip_BaseTooltip, {\n        placement: "bottom"\n      }, react_default.a.createElement(components_DocLabel, null, "Bottom")), react_default.a.createElement(Tooltip_BaseTooltip, {\n        placement: "left"\n      }, react_default.a.createElement(components_DocLabel, null, "Left")));\n    }\n  }]);\n\n  return MDXContent;\n}(react_default.a.Component);\n\n\n// CONCATENATED MODULE: ./src/docs/Chip.mdx\nfunction Chip_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Chip_typeof = function _typeof(obj) { return typeof obj; }; } else { Chip_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Chip_typeof(obj); }\n\nfunction Chip_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Chip_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Chip_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction Chip_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Chip_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Chip_createClass(Constructor, protoProps, staticProps) { if (protoProps) Chip_defineProperties(Constructor.prototype, protoProps); if (staticProps) Chip_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction Chip_possibleConstructorReturn(self, call) { if (call && (Chip_typeof(call) === "object" || typeof call === "function")) { return call; } return Chip_assertThisInitialized(self); }\n\nfunction Chip_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction Chip_getPrototypeOf(o) { Chip_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Chip_getPrototypeOf(o); }\n\nfunction Chip_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Chip_setPrototypeOf(subClass, superClass); }\n\nfunction Chip_setPrototypeOf(o, p) { Chip_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Chip_setPrototypeOf(o, p); }\n\n\n\n\n\nvar Chip_MDXContent =\n/*#__PURE__*/\nfunction (_React$Component) {\n  Chip_inherits(MDXContent, _React$Component);\n\n  function MDXContent(props) {\n    var _this;\n\n    Chip_classCallCheck(this, MDXContent);\n\n    _this = Chip_possibleConstructorReturn(this, Chip_getPrototypeOf(MDXContent).call(this, props));\n    _this.layout = null;\n    return _this;\n  }\n\n  Chip_createClass(MDXContent, [{\n    key: "render",\n    value: function render() {\n      var _this$props = this.props,\n          components = _this$props.components,\n          props = Chip_objectWithoutProperties(_this$props, ["components"]);\n\n      return react_default.a.createElement(dist["MDXTag"], {\n        name: "wrapper",\n        components: components\n      }, react_default.a.createElement(dist["MDXTag"], {\n        name: "p",\n        components: components\n      }, react_default.a.createElement("a", {\n        id: "Chips"\n      })), react_default.a.createElement(dist["MDXTag"], {\n        name: "h1",\n        components: components\n      }, "Chips"), react_default.a.createElement(build["Chip"], {\n        mr: 1,\n        text: "Jack White"\n      }), react_default.a.createElement(build["Chip"], {\n        mr: 1,\n        text: "Adele",\n        dismissable: true\n      }), react_default.a.createElement(build["Chip"], {\n        mr: 1,\n        bg: "secondary",\n        text: "Freddie Mercury",\n        dismissable: true\n      }), react_default.a.createElement(build["Chip"], {\n        mr: 1,\n        bg: "tertiary",\n        text: "Thom Yorke"\n      }), react_default.a.createElement(build["Chip"], {\n        mr: 1,\n        text: "Duran Duran",\n        avatarUrl: "https://images.pexels.com/photos/109243/pexels-photo-109243.jpeg?auto=compress&cs=tinysrgb&dpr=2&h=750&w=1260"\n      }));\n    }\n  }]);\n\n  return MDXContent;\n}(react_default.a.Component);\n\n\n// CONCATENATED MODULE: ./src/docs/Tags.mdx\nfunction Tags_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Tags_typeof = function _typeof(obj) { return typeof obj; }; } else { Tags_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Tags_typeof(obj); }\n\nfunction Tags_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Tags_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Tags_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction Tags_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Tags_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Tags_createClass(Constructor, protoProps, staticProps) { if (protoProps) Tags_defineProperties(Constructor.prototype, protoProps); if (staticProps) Tags_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction Tags_possibleConstructorReturn(self, call) { if (call && (Tags_typeof(call) === "object" || typeof call === "function")) { return call; } return Tags_assertThisInitialized(self); }\n\nfunction Tags_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction Tags_getPrototypeOf(o) { Tags_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Tags_getPrototypeOf(o); }\n\nfunction Tags_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Tags_setPrototypeOf(subClass, superClass); }\n\nfunction Tags_setPrototypeOf(o, p) { Tags_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Tags_setPrototypeOf(o, p); }\n\n\n\n\n\nvar Tags_MDXContent =\n/*#__PURE__*/\nfunction (_React$Component) {\n  Tags_inherits(MDXContent, _React$Component);\n\n  function MDXContent(props) {\n    var _this;\n\n    Tags_classCallCheck(this, MDXContent);\n\n    _this = Tags_possibleConstructorReturn(this, Tags_getPrototypeOf(MDXContent).call(this, props));\n    _this.layout = null;\n    return _this;\n  }\n\n  Tags_createClass(MDXContent, [{\n    key: "render",\n    value: function render() {\n      var _this$props = this.props,\n          components = _this$props.components,\n          props = Tags_objectWithoutProperties(_this$props, ["components"]);\n\n      return react_default.a.createElement(dist["MDXTag"], {\n        name: "wrapper",\n        components: components\n      }, react_default.a.createElement(dist["MDXTag"], {\n        name: "p",\n        components: components\n      }, react_default.a.createElement("a", {\n        id: "Tags"\n      })), react_default.a.createElement(dist["MDXTag"], {\n        name: "h1",\n        components: components\n      }, "Tags"), react_default.a.createElement(build["Tag"], {\n        mr: 1,\n        text: "Jack White"\n      }), react_default.a.createElement(build["Tag"], {\n        mr: 1,\n        text: "Adele",\n        dismissable: true\n      }), react_default.a.createElement(build["Tag"], {\n        mr: 1,\n        bg: "secondary",\n        text: "Freddie Mercury",\n        dismissable: true\n      }), react_default.a.createElement(build["Tag"], {\n        mr: 1,\n        bg: "tertiary",\n        text: "Thom Yorke"\n      }), react_default.a.createElement(build["Tag"], {\n        mr: 1,\n        text: "Duran Duran",\n        avatarUrl: "https://images.pexels.com/photos/109243/pexels-photo-109243.jpeg?auto=compress&cs=tinysrgb&dpr=2&h=750&w=1260"\n      }));\n    }\n  }]);\n\n  return MDXContent;\n}(react_default.a.Component);\n\n\n// CONCATENATED MODULE: ./src/docs/Avatars.mdx\nfunction Avatars_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Avatars_typeof = function _typeof(obj) { return typeof obj; }; } else { Avatars_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Avatars_typeof(obj); }\n\nfunction Avatars_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Avatars_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction Avatars_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction Avatars_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Avatars_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Avatars_createClass(Constructor, protoProps, staticProps) { if (protoProps) Avatars_defineProperties(Constructor.prototype, protoProps); if (staticProps) Avatars_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction Avatars_possibleConstructorReturn(self, call) { if (call && (Avatars_typeof(call) === "object" || typeof call === "function")) { return call; } return Avatars_assertThisInitialized(self); }\n\nfunction Avatars_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction Avatars_getPrototypeOf(o) { Avatars_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Avatars_getPrototypeOf(o); }\n\nfunction Avatars_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Avatars_setPrototypeOf(subClass, superClass); }\n\nfunction Avatars_setPrototypeOf(o, p) { Avatars_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Avatars_setPrototypeOf(o, p); }\n\nfunction Avatars_extends() { Avatars_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return Avatars_extends.apply(this, arguments); }\n\n\n\n\n\nvar demoSrc = \'https://images.pexels.com/photos/109243/pexels-photo-109243.jpeg?auto=compress&cs=tinysrgb&dpr=2&h=750&w=1260\';\n\nvar Avatars_Label = function Label(props) {\n  return react_default.a.createElement(components_DocLabel, Avatars_extends({\n    mr: 1,\n    mt: 2\n  }, props));\n};\n\nvar Avatars_MDXContent =\n/*#__PURE__*/\nfunction (_React$Component) {\n  Avatars_inherits(MDXContent, _React$Component);\n\n  function MDXContent(props) {\n    var _this;\n\n    Avatars_classCallCheck(this, MDXContent);\n\n    _this = Avatars_possibleConstructorReturn(this, Avatars_getPrototypeOf(MDXContent).call(this, props));\n    _this.layout = null;\n    return _this;\n  }\n\n  Avatars_createClass(MDXContent, [{\n    key: "render",\n    value: function render() {\n      var _this$props = this.props,\n          components = _this$props.components,\n          props = Avatars_objectWithoutProperties(_this$props, ["components"]);\n\n      return react_default.a.createElement(dist["MDXTag"], {\n        name: "wrapper",\n        components: components\n      }, react_default.a.createElement(dist["MDXTag"], {\n        name: "p",\n        components: components\n      }, react_default.a.createElement("a", {\n        id: "Avatars"\n      })), react_default.a.createElement(dist["MDXTag"], {\n        name: "h1",\n        components: components\n      }, "Avatars"), react_default.a.createElement("div", {\n        style: {\n          display: \'flex\',\n          alignItems: \'flex-end\'\n        }\n      }, react_default.a.createElement("div", null, react_default.a.createElement(build["Avatar"], {\n        mx: 2,\n        size: "jumbo",\n        src: demoSrc\n      }), react_default.a.createElement(Avatars_Label, null, "Jumbo")), react_default.a.createElement("div", null, react_default.a.createElement(build["Avatar"], {\n        mx: 2,\n        size: "large",\n        src: demoSrc\n      }), react_default.a.createElement(Avatars_Label, null, "Large")), react_default.a.createElement("div", null, react_default.a.createElement(build["Avatar"], {\n        mx: 2,\n        size: "medium",\n        src: demoSrc\n      }), react_default.a.createElement(Avatars_Label, null, "Medium")), react_default.a.createElement("div", null, react_default.a.createElement(build["Avatar"], {\n        mx: 2,\n        size: "small",\n        src: demoSrc\n      }), react_default.a.createElement(Avatars_Label, null, "Small"))));\n    }\n  }]);\n\n  return MDXContent;\n}(react_default.a.Component);\n\n\n// CONCATENATED MODULE: ./src/pages/ComponentLibrary.js\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return StyleGuide; });\nfunction ComponentLibrary_extends() { ComponentLibrary_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return ComponentLibrary_extends.apply(this, arguments); }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar ComponentLibrary_H1 = function H1(props) {\n  return react_default.a.createElement(build["HeadingThree"], ComponentLibrary_extends({\n    is: "h1",\n    pt: 12,\n    mb: 2,\n    style: {\n      display: \'block\',\n      borderBottom: \'1px solid lightgrey\'\n    }\n  }, props));\n};\n\nvar ComponentLibrary_H2 = function H2(props) {\n  return react_default.a.createElement(build["HeadingFive"], ComponentLibrary_extends({\n    is: "h2",\n    my: 2\n  }, props));\n};\n\nvar ComponentLibrary_DocsText = function DocsText(props) {\n  return react_default.a.createElement(build["BodyText"], ComponentLibrary_extends({\n    pb: 2\n  }, props));\n};\n\nvar ComponentLibrary_components = {\n  h1: ComponentLibrary_H1,\n  h2: ComponentLibrary_H2,\n  p: ComponentLibrary_DocsText //   // ...\n  //   code: Pre,\n  //   inlineCode: Code\n\n};\nfunction StyleGuide() {\n  return react_default.a.createElement(dist["MDXProvider"], {\n    components: ComponentLibrary_components\n  }, react_default.a.createElement(build["Box"], {\n    display: "flex"\n  }, react_default.a.createElement(DocsNav, null), react_default.a.createElement(build["Box"], {\n    ml: 246,\n    maxWidth: 1000,\n    px: 4\n  }, react_default.a.createElement(build["HeadingOne"], {\n    mt: 3\n  }, "Component Library"), react_default.a.createElement(Avatars_MDXContent, null), react_default.a.createElement(Button_MDXContent, null), react_default.a.createElement(Card_MDXContent, null), react_default.a.createElement(Chip_MDXContent, null), react_default.a.createElement(Forms_MDXContent, null), react_default.a.createElement(Icon_MDXContent, null), react_default.a.createElement(NotificationBar_MDXContent, null), react_default.a.createElement(Pagination_MDXContent, null), react_default.a.createElement(ProgressBar_MDXContent, null), react_default.a.createElement(Tabs_MDXContent, null), react_default.a.createElement(Tags_MDXContent, null), react_default.a.createElement(Text_MDXContent, null), react_default.a.createElement(Tooltip_MDXContent, null))));\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDc5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2RvY3MvQnV0dG9uLm1keD81YzIyIiwid2VicGFjazovLy8uL3NyYy9kb2NzL0NhcmQubWR4PzFhZDYiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RvY3MvRm9ybXMvQ2hlY2tib3guanM/MDBjYiIsIndlYnBhY2s6Ly8vLi9zcmMvZG9jcy9Gb3Jtcy9SYWRpby5qcz9iZDI2Iiwid2VicGFjazovLy8uL3NyYy9kb2NzL0Zvcm1zL2luZGV4Lm1keD9mNDcwIiwid2VicGFjazovLy8uL3NyYy9kb2NzL0ljb24ubWR4P2Y0Y2YiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NlcnZpY2VzL2luZGV4LmpzPzRlMmQiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvRG9jc05hdi5qcz9mZGNiIiwid2VicGFjazovLy8uL3NyYy9kb2NzL05vdGlmaWNhdGlvbkJhci5tZHg/MTc2ZCIsIndlYnBhY2s6Ly8vLi9zcmMvZG9jcy9QYWdpbmF0aW9uLm1keD83NTJkIiwid2VicGFjazovLy8uL3NyYy9kb2NzL1Byb2dyZXNzQmFyL2hlbHBlcnMuanM/ZWJkMiIsIndlYnBhY2s6Ly8vLi9zcmMvZG9jcy9Qcm9ncmVzc0Jhci9pbmRleC5tZHg/YjQ1YiIsIndlYnBhY2s6Ly8vLi9zcmMvZG9jcy9UYWJzLm1keD84NGY4Iiwid2VicGFjazovLy8uL3NyYy9kb2NzL1RleHQubWR4PzYyNDUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvRG9jTGFiZWwuanM/ODIyNSIsIndlYnBhY2s6Ly8vLi9zcmMvZG9jcy9Ub29sdGlwLm1keD84YjAyIiwid2VicGFjazovLy8uL3NyYy9kb2NzL0NoaXAubWR4P2Y4NDkiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RvY3MvVGFncy5tZHg/YmU5ZCIsIndlYnBhY2s6Ly8vLi9zcmMvZG9jcy9BdmF0YXJzLm1keD9kM2U4Iiwid2VicGFjazovLy8uL3NyYy9wYWdlcy9Db21wb25lbnRMaWJyYXJ5LmpzPzUxODciXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyB2YXIga2V5LCBpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBNRFhUYWcgfSBmcm9tICdAbWR4LWpzL3RhZyc7XG5pbXBvcnQgeyBCdXR0b24sIEJ1dHRvbkxhcmdlLCBCdXR0b25TbWFsbCB9IGZyb20gJ2NhYmFuYS1yZWFjdCc7XG5pbXBvcnQgeyBJY29uSGVhcnQgfSBmcm9tICdjYWJhbmFpY28nO1xudmFyIHByaW1hcnlQcm9wcyA9IHtcbiAgYmc6ICdwcmltYXJ5JyxcbiAgY29sb3I6ICd3aGl0ZScsXG4gIG1yOiAxXG59O1xuXG52YXIgTURYQ29udGVudCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoTURYQ29udGVudCwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gTURYQ29udGVudChwcm9wcykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNRFhDb250ZW50KTtcblxuICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKE1EWENvbnRlbnQpLmNhbGwodGhpcywgcHJvcHMpKTtcbiAgICBfdGhpcy5sYXlvdXQgPSBudWxsO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhNRFhDb250ZW50LCBbe1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICBjb21wb25lbnRzID0gX3RoaXMkcHJvcHMuY29tcG9uZW50cyxcbiAgICAgICAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfdGhpcyRwcm9wcywgW1wiY29tcG9uZW50c1wiXSk7XG5cbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KE1EWFRhZywge1xuICAgICAgICBuYW1lOiBcIndyYXBwZXJcIixcbiAgICAgICAgY29tcG9uZW50czogY29tcG9uZW50c1xuICAgICAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChNRFhUYWcsIHtcbiAgICAgICAgbmFtZTogXCJwXCIsXG4gICAgICAgIGNvbXBvbmVudHM6IGNvbXBvbmVudHNcbiAgICAgIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJhXCIsIHtcbiAgICAgICAgaWQ6IFwiQnV0dG9uc1wiXG4gICAgICB9KSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTURYVGFnLCB7XG4gICAgICAgIG5hbWU6IFwiaDFcIixcbiAgICAgICAgY29tcG9uZW50czogY29tcG9uZW50c1xuICAgICAgfSwgXCJCdXR0b25zXCIpLCBSZWFjdC5jcmVhdGVFbGVtZW50KE1EWFRhZywge1xuICAgICAgICBuYW1lOiBcImgyXCIsXG4gICAgICAgIGNvbXBvbmVudHM6IGNvbXBvbmVudHNcbiAgICAgIH0sIFwiU21hbGxcIiksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQnV0dG9uU21hbGwsIHByaW1hcnlQcm9wcywgXCJCdXR0b25cIiksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQnV0dG9uU21hbGwsIHByaW1hcnlQcm9wcywgUmVhY3QuY3JlYXRlRWxlbWVudChJY29uSGVhcnQsIG51bGwpLCBcIiBCdXR0b25cIiksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQnV0dG9uU21hbGwsIHByaW1hcnlQcm9wcywgXCJCdXR0b24gXCIsIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSWNvbkhlYXJ0LCBudWxsKSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTURYVGFnLCB7XG4gICAgICAgIG5hbWU6IFwiaDJcIixcbiAgICAgICAgY29tcG9uZW50czogY29tcG9uZW50c1xuICAgICAgfSwgXCJOb3JtYWxcIiksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQnV0dG9uLCBwcmltYXJ5UHJvcHMsIFwiQnV0dG9uXCIpLCBSZWFjdC5jcmVhdGVFbGVtZW50KEJ1dHRvbiwgcHJpbWFyeVByb3BzLCBSZWFjdC5jcmVhdGVFbGVtZW50KEljb25IZWFydCwgbnVsbCksIFwiIEJ1dHRvblwiKSwgUmVhY3QuY3JlYXRlRWxlbWVudChCdXR0b24sIHByaW1hcnlQcm9wcywgXCJCdXR0b24gXCIsIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSWNvbkhlYXJ0LCBudWxsKSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTURYVGFnLCB7XG4gICAgICAgIG5hbWU6IFwiaDJcIixcbiAgICAgICAgY29tcG9uZW50czogY29tcG9uZW50c1xuICAgICAgfSwgXCJMYXJnZVwiKSwgUmVhY3QuY3JlYXRlRWxlbWVudChCdXR0b25MYXJnZSwgX2V4dGVuZHMoe30sIHByaW1hcnlQcm9wcywge1xuICAgICAgICBmb250V2VpZ2h0OiBcImJvbGRcIlxuICAgICAgfSksIFwiQnV0dG9uXCIpLCBSZWFjdC5jcmVhdGVFbGVtZW50KEJ1dHRvbkxhcmdlLCBfZXh0ZW5kcyh7fSwgcHJpbWFyeVByb3BzLCB7XG4gICAgICAgIGZvbnRXZWlnaHQ6IFwiYm9sZFwiXG4gICAgICB9KSwgUmVhY3QuY3JlYXRlRWxlbWVudChJY29uSGVhcnQsIG51bGwpLCBcIiBCdXR0b25cIiksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQnV0dG9uTGFyZ2UsIF9leHRlbmRzKHt9LCBwcmltYXJ5UHJvcHMsIHtcbiAgICAgICAgZm9udFdlaWdodDogXCJib2xkXCJcbiAgICAgIH0pLCBcIkJ1dHRvbiBcIiwgUmVhY3QuY3JlYXRlRWxlbWVudChJY29uSGVhcnQsIG51bGwpKSwgUmVhY3QuY3JlYXRlRWxlbWVudChNRFhUYWcsIHtcbiAgICAgICAgbmFtZTogXCJoMlwiLFxuICAgICAgICBjb21wb25lbnRzOiBjb21wb25lbnRzXG4gICAgICB9LCBcIkNvbG91cmZ1bFwiKSwgUmVhY3QuY3JlYXRlRWxlbWVudChCdXR0b25TbWFsbCwge1xuICAgICAgICBiZzogXCJlcnJvclwiLFxuICAgICAgICBib3JkZXJSYWRpdXM6IFwibGFyZ2VcIixcbiAgICAgICAgY29sb3I6IFwid2hpdGVcIlxuICAgICAgfSwgXCJCdXR0b25cIiksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQnV0dG9uLCB7XG4gICAgICAgIGJnOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgY29sb3I6IFwiZXJyb3JcIlxuICAgICAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChJY29uSGVhcnQsIG51bGwpLCBcIiBCdXR0b25cIiksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQnV0dG9uTGFyZ2UsIHtcbiAgICAgICAgYmc6IFwidGVydGlhcnlcIixcbiAgICAgICAgY29sb3I6IFwid2FybmluZ1wiXG4gICAgICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KEljb25IZWFydCwgbnVsbCksIFwiIEJ1dHRvblwiKSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE1EWENvbnRlbnQ7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbmV4cG9ydCB7IE1EWENvbnRlbnQgYXMgZGVmYXVsdCB9OyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7IHZhciBrZXksIGk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgdmFyIGtleSwgaTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgTURYVGFnIH0gZnJvbSAnQG1keC1qcy90YWcnO1xuaW1wb3J0IHsgQnV0dG9uLCBCdXR0b25TbWFsbCwgQ2FyZCwgQ2FyZEJvZHlUZXh0LCBDYXJkRm9vdGVyLCBDYXJkSW1hZ2UsIENhcmRUaXRsZSwgVGlueVRleHQgfSBmcm9tICdjYWJhbmEtcmVhY3QnO1xuaW1wb3J0IHsgSWNvbkhlYXJ0IH0gZnJvbSAnY2FiYW5haWNvJztcbnZhciBTYW1wbGVCb2R5VGV4dCA9IFwiSGV5IHRoZXJlISBJJ20gVG9tLiBBIHNpbmdlciwgd2hvJ3Mgd2VsbCBrbm93biBmb3IgbXkgdmFyaW91cyBhd2Vzb21lIGphbXMsIGFuZCBvdGhlciBhbWF6aW5nIHRoYW5ncy5cIjtcblxudmFyIE1EWENvbnRlbnQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKE1EWENvbnRlbnQsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIE1EWENvbnRlbnQocHJvcHMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTURYQ29udGVudCk7XG5cbiAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihNRFhDb250ZW50KS5jYWxsKHRoaXMsIHByb3BzKSk7XG4gICAgX3RoaXMubGF5b3V0ID0gbnVsbDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTURYQ29udGVudCwgW3tcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgY29tcG9uZW50cyA9IF90aGlzJHByb3BzLmNvbXBvbmVudHMsXG4gICAgICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3RoaXMkcHJvcHMsIFtcImNvbXBvbmVudHNcIl0pO1xuXG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChNRFhUYWcsIHtcbiAgICAgICAgbmFtZTogXCJ3cmFwcGVyXCIsXG4gICAgICAgIGNvbXBvbmVudHM6IGNvbXBvbmVudHNcbiAgICAgIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTURYVGFnLCB7XG4gICAgICAgIG5hbWU6IFwicFwiLFxuICAgICAgICBjb21wb25lbnRzOiBjb21wb25lbnRzXG4gICAgICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYVwiLCB7XG4gICAgICAgIGlkOiBcIkNhcmRzXCJcbiAgICAgIH0pKSwgUmVhY3QuY3JlYXRlRWxlbWVudChNRFhUYWcsIHtcbiAgICAgICAgbmFtZTogXCJoMVwiLFxuICAgICAgICBjb21wb25lbnRzOiBjb21wb25lbnRzXG4gICAgICB9LCBcIkNhcmRzXCIpLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICBtYXhXaWR0aDogMTAyNCxcbiAgICAgICAgICBkaXNwbGF5OiAnZ3JpZCcsXG4gICAgICAgICAgZ3JpZFRlbXBsYXRlQ29sdW1uczogJzFmciAxZnIgMWZyJyxcbiAgICAgICAgICBncmlkQ29sdW1uR2FwOiAxMCxcbiAgICAgICAgICBncmlkUm93R2FwOiAzMCxcbiAgICAgICAgICBhbGlnbkl0ZW1zOiAnc3RhcnQnXG4gICAgICAgIH1cbiAgICAgIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ2FyZCwge1xuICAgICAgICBpczogXCJhcnRpY2xlXCIsXG4gICAgICAgIHRleHRBbGlnbjogXCJjZW50ZXJcIlxuICAgICAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChDYXJkSW1hZ2UsIG51bGwpLCBSZWFjdC5jcmVhdGVFbGVtZW50KENhcmRUaXRsZSwgbnVsbCwgXCJUb20gSm9uZXNcIiksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ2FyZEJvZHlUZXh0LCB7XG4gICAgICAgIG1iOiA0LFxuICAgICAgICBkaXNwbGF5OiBcImlubGluZS1ibG9ja1wiXG4gICAgICB9LCBTYW1wbGVCb2R5VGV4dCksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQnV0dG9uLCB7XG4gICAgICAgIGJnOiBcInByaW1hcnlcIixcbiAgICAgICAgY29sb3I6IFwid2hpdGVcIixcbiAgICAgICAgYm9yZGVyUmFkaXVzOiBcImxhcmdlXCJcbiAgICAgIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSWNvbkhlYXJ0LCBudWxsKSwgXCJGb2xsb3cgbWUgb24gVHdpdHRlclwiKSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ2FyZCwge1xuICAgICAgICBpczogXCJhcnRpY2xlXCIsXG4gICAgICAgIHRleHRBbGlnbjogXCJjZW50ZXJcIlxuICAgICAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChDYXJkSW1hZ2UsIHtcbiAgICAgICAgaGVpZ2h0OiBcIjI0MHB4XCJcbiAgICAgIH0pLCBSZWFjdC5jcmVhdGVFbGVtZW50KENhcmRUaXRsZSwgbnVsbCwgXCJUb20gSm9uZXNcIiksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ2FyZEJvZHlUZXh0LCB7XG4gICAgICAgIG1iOiA0LFxuICAgICAgICBkaXNwbGF5OiBcImlubGluZS1ibG9ja1wiXG4gICAgICB9LCBTYW1wbGVCb2R5VGV4dCksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQnV0dG9uLCB7XG4gICAgICAgIGJnOiBcInByaW1hcnlcIixcbiAgICAgICAgY29sb3I6IFwid2hpdGVcIlxuICAgICAgfSwgXCJWaWV3IEZ1bGwgUHJvZmlsZVwiKSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ2FyZCwge1xuICAgICAgICBpczogXCJhcnRpY2xlXCJcbiAgICAgIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ2FyZEltYWdlLCBudWxsKSwgUmVhY3QuY3JlYXRlRWxlbWVudChDYXJkVGl0bGUsIG51bGwsIFwiVG9tIEpvbmVzXCIpLCBSZWFjdC5jcmVhdGVFbGVtZW50KENhcmRCb2R5VGV4dCwgbnVsbCwgU2FtcGxlQm9keVRleHQpLCBSZWFjdC5jcmVhdGVFbGVtZW50KENhcmRGb290ZXIsIG51bGwsIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVGlueVRleHQsIHtcbiAgICAgICAgY29sb3I6IFwiZ3JleVwiXG4gICAgICB9LCBcIjIzIEZyaWVuZHNcIikpKSwgUmVhY3QuY3JlYXRlRWxlbWVudChDYXJkLCB7XG4gICAgICAgIGlzOiBcImFydGljbGVcIixcbiAgICAgICAgcDogOFxuICAgICAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChDYXJkVGl0bGUsIG51bGwsIFwiTW9yZSBQYWRkaW5nXCIpLCBSZWFjdC5jcmVhdGVFbGVtZW50KENhcmRCb2R5VGV4dCwgbnVsbCwgU2FtcGxlQm9keVRleHQpKSwgUmVhY3QuY3JlYXRlRWxlbWVudChDYXJkLCB7XG4gICAgICAgIGlzOiBcImFydGljbGVcIixcbiAgICAgICAgYmc6IFwic2Vjb25kYXJ5XCIsXG4gICAgICAgIGJvcmRlclJhZGl1czogXCJzbWFsbFwiLFxuICAgICAgICBib3hTaGFkb3c6IDYwXG4gICAgICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KENhcmRUaXRsZSwge1xuICAgICAgICBjb2xvcjogXCJ3YXJuaW5nXCIsXG4gICAgICAgIGZvbnRXZWlnaHQ6IFwibm9ybWFsXCJcbiAgICAgIH0sIFwiRmFuY3kgc2Vjb25kYXJ5IG9uZVwiKSwgUmVhY3QuY3JlYXRlRWxlbWVudChDYXJkQm9keVRleHQsIHtcbiAgICAgICAgY29sb3I6IFwid2hpdGVcIlxuICAgICAgfSwgXCIgXCIsIFNhbXBsZUJvZHlUZXh0KSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ2FyZCwge1xuICAgICAgICBpczogXCJhcnRpY2xlXCIsXG4gICAgICAgIGJvcmRlclJhZGl1czogXCJzbWFsbFwiLFxuICAgICAgICBib3hTaGFkb3c6IDYwXG4gICAgICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KENhcmRUaXRsZSwge1xuICAgICAgICBjb2xvcjogXCJzdWNjZXNzXCIsXG4gICAgICAgIGZvbnRXZWlnaHQ6IFwibm9ybWFsXCIsXG4gICAgICAgIG1iOiAwXG4gICAgICB9LCBcIlN1Y2Nlc3MhXCIpKSkpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBNRFhDb250ZW50O1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5leHBvcnQgeyBNRFhDb250ZW50IGFzIGRlZmF1bHQgfTsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuaW1wb3J0IHsgQm94LCBDaGVja2JveCB9IGZyb20gJ2NhYmFuYS1yZWFjdCc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG52YXIgU3RhdGVmdWxDaGVja2JveCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoU3RhdGVmdWxDaGVja2JveCwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gU3RhdGVmdWxDaGVja2JveCgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3RhdGVmdWxDaGVja2JveCk7XG5cbiAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihTdGF0ZWZ1bENoZWNrYm94KS5jYWxsKHRoaXMpKTtcbiAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGNoZWNrZWQ6IGZhbHNlXG4gICAgfTtcbiAgICBfdGhpcy5oYW5kbGVDaGFuZ2UgPSBfdGhpcy5oYW5kbGVDaGFuZ2UuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFN0YXRlZnVsQ2hlY2tib3gsIFt7XG4gICAga2V5OiBcImhhbmRsZUNoYW5nZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVDaGFuZ2UoKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgY2hlY2tlZDogIXRoaXMuc3RhdGUuY2hlY2tlZFxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIGxhYmVsID0gX3RoaXMkcHJvcHMubGFiZWwsXG4gICAgICAgICAgdmFsdWUgPSBfdGhpcyRwcm9wcy52YWx1ZSxcbiAgICAgICAgICBkaXNhYmxlZCA9IF90aGlzJHByb3BzLmRpc2FibGVkO1xuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ2hlY2tib3gsIHtcbiAgICAgICAgZGlzYWJsZWQ6IGRpc2FibGVkLFxuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGxhYmVsOiBsYWJlbCxcbiAgICAgICAgY2hlY2tlZDogdGhpcy5zdGF0ZS5jaGVja2VkLFxuICAgICAgICBvbkNoYW5nZTogdGhpcy5oYW5kbGVDaGFuZ2UsXG4gICAgICAgIHB5OiAxXG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU3RhdGVmdWxDaGVja2JveDtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxudmFyIENoZWNrYm94ZXMgPSBmdW5jdGlvbiBDaGVja2JveGVzKCkge1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChCb3gsIHtcbiAgICBkaXNwbGF5OiBcImdyaWRcIixcbiAgICBzdHlsZToge1xuICAgICAgZ3JpZFRlbXBsYXRlQ29sdW1uczogJzFmcicsXG4gICAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJ1xuICAgIH1cbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChTdGF0ZWZ1bENoZWNrYm94LCB7XG4gICAgdmFsdWU6IFwiamFyX2phclwiLFxuICAgIGxhYmVsOiBcIkphciBKYXIgQmlua3NcIlxuICB9KSwgUmVhY3QuY3JlYXRlRWxlbWVudChTdGF0ZWZ1bENoZWNrYm94LCB7XG4gICAgdmFsdWU6IFwicXVlZW5fYW1pZGFsYVwiLFxuICAgIGxhYmVsOiBcIlF1ZWVuIEFtaWRhbGFcIlxuICB9KSwgUmVhY3QuY3JlYXRlRWxlbWVudChTdGF0ZWZ1bENoZWNrYm94LCB7XG4gICAgZGlzYWJsZWQ6IHRydWUsXG4gICAgdmFsdWU6IFwibW9uX21vdGhtYVwiLFxuICAgIGxhYmVsOiBcIk1vbiBNb3RobWFcIlxuICB9KSk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBDaGVja2JveGVzOyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5pbXBvcnQgeyBCb3gsIFJhZGlvIH0gZnJvbSAnY2FiYW5hLXJlYWN0JztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbnZhciBTdGF0ZWZ1bFJhZGlvQnV0dG9ucyA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoU3RhdGVmdWxSYWRpb0J1dHRvbnMsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFN0YXRlZnVsUmFkaW9CdXR0b25zKCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdGF0ZWZ1bFJhZGlvQnV0dG9ucyk7XG5cbiAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihTdGF0ZWZ1bFJhZGlvQnV0dG9ucykuY2FsbCh0aGlzKSk7XG4gICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICBzZWxlY3RlZDogJ2FuYWtpbl9za3l3YWxrZXInXG4gICAgfTtcbiAgICBfdGhpcy5oYW5kbGVDaGFuZ2UgPSBfdGhpcy5oYW5kbGVDaGFuZ2UuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFN0YXRlZnVsUmFkaW9CdXR0b25zLCBbe1xuICAgIGtleTogXCJoYW5kbGVDaGFuZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlQ2hhbmdlKGV2ZW50KSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgc2VsZWN0ZWQ6IGV2ZW50LnRhcmdldC52YWx1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgX1JlYWN0JGNyZWF0ZUVsZW1lbnQ7XG5cbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KEJveCwge1xuICAgICAgICBkaXNwbGF5OiBcImdyaWRcIixcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICBncmlkVGVtcGxhdGVDb2x1bW5zOiAnMWZyJyxcbiAgICAgICAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJ1xuICAgICAgICB9XG4gICAgICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFJhZGlvLCB7XG4gICAgICAgIHZhbHVlOiBcIm9iaV93YW5cIixcbiAgICAgICAgbGFiZWw6IFwiT2JpIFdhbiBLZW5vYmlcIixcbiAgICAgICAgY2hlY2tlZDogdGhpcy5zdGF0ZS5zZWxlY3RlZCA9PT0gJ29iaV93YW4nLFxuICAgICAgICBvbkNoYW5nZTogdGhpcy5oYW5kbGVDaGFuZ2UsXG4gICAgICAgIHB5OiAxXG4gICAgICB9KSwgUmVhY3QuY3JlYXRlRWxlbWVudChSYWRpbywge1xuICAgICAgICB2YWx1ZTogXCJoYW5fc29sb1wiLFxuICAgICAgICBsYWJlbDogXCJIYW4gU29sb1wiLFxuICAgICAgICBjaGVja2VkOiB0aGlzLnN0YXRlLnNlbGVjdGVkID09PSAnaGFuX3NvbG8nLFxuICAgICAgICBvbkNoYW5nZTogdGhpcy5oYW5kbGVDaGFuZ2UsXG4gICAgICAgIHB5OiAxXG4gICAgICB9KSwgUmVhY3QuY3JlYXRlRWxlbWVudChSYWRpbywgKF9SZWFjdCRjcmVhdGVFbGVtZW50ID0ge1xuICAgICAgICB2YWx1ZTogXCJhbmFraW5fc2t5d2Fsa2VyXCIsXG4gICAgICAgIGxhYmVsOiBcIkFuYWtpbiBTa3l3YWxrZXJcIixcbiAgICAgICAgY2hlY2tlZDogdHJ1ZSxcbiAgICAgICAgZGlzYWJsZWQ6IHRydWVcbiAgICAgIH0sIF9kZWZpbmVQcm9wZXJ0eShfUmVhY3QkY3JlYXRlRWxlbWVudCwgXCJjaGVja2VkXCIsIHRoaXMuc3RhdGUuc2VsZWN0ZWQgPT09ICdhbmFraW5fc2t5d2Fsa2VyJyksIF9kZWZpbmVQcm9wZXJ0eShfUmVhY3QkY3JlYXRlRWxlbWVudCwgXCJvbkNoYW5nZVwiLCB0aGlzLmhhbmRsZUNoYW5nZSksIF9kZWZpbmVQcm9wZXJ0eShfUmVhY3QkY3JlYXRlRWxlbWVudCwgXCJweVwiLCAxKSwgX1JlYWN0JGNyZWF0ZUVsZW1lbnQpKSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFN0YXRlZnVsUmFkaW9CdXR0b25zO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5leHBvcnQgZGVmYXVsdCBTdGF0ZWZ1bFJhZGlvQnV0dG9uczsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IE1EWFRhZyB9IGZyb20gJ0BtZHgtanMvdGFnJztcbmltcG9ydCB7IEJveCwgRm9ybUxhYmVsLCBIZWFkaW5nRml2ZSwgVGV4dElucHV0LCBWYWxpZGF0aW9uTGFiZWwgfSBmcm9tICdjYWJhbmEtcmVhY3QnO1xuaW1wb3J0IENoZWNrYm94ZXMgZnJvbSAnLi9DaGVja2JveCc7XG5pbXBvcnQgU3RhdGVmdWxSYWRpb0J1dHRvbnMgZnJvbSAnLi9SYWRpbyc7XG5cbnZhciBNRFhDb250ZW50ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhNRFhDb250ZW50LCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBNRFhDb250ZW50KHByb3BzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1EWENvbnRlbnQpO1xuXG4gICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoTURYQ29udGVudCkuY2FsbCh0aGlzLCBwcm9wcykpO1xuICAgIF90aGlzLmxheW91dCA9IG51bGw7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKE1EWENvbnRlbnQsIFt7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIGNvbXBvbmVudHMgPSBfdGhpcyRwcm9wcy5jb21wb25lbnRzLFxuICAgICAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF90aGlzJHByb3BzLCBbXCJjb21wb25lbnRzXCJdKTtcblxuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTURYVGFnLCB7XG4gICAgICAgIG5hbWU6IFwid3JhcHBlclwiLFxuICAgICAgICBjb21wb25lbnRzOiBjb21wb25lbnRzXG4gICAgICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KE1EWFRhZywge1xuICAgICAgICBuYW1lOiBcInBcIixcbiAgICAgICAgY29tcG9uZW50czogY29tcG9uZW50c1xuICAgICAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImFcIiwge1xuICAgICAgICBpZDogXCJGb3Jtc1wiXG4gICAgICB9KSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTURYVGFnLCB7XG4gICAgICAgIG5hbWU6IFwiaDFcIixcbiAgICAgICAgY29tcG9uZW50czogY29tcG9uZW50c1xuICAgICAgfSwgXCJGb3Jtc1wiKSwgUmVhY3QuY3JlYXRlRWxlbWVudChNRFhUYWcsIHtcbiAgICAgICAgbmFtZTogXCJoMlwiLFxuICAgICAgICBjb21wb25lbnRzOiBjb21wb25lbnRzXG4gICAgICB9LCBcIlRvZG86XCIpLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwidWxcIiwgbnVsbCwgUmVhY3QuY3JlYXRlRWxlbWVudChcImxpXCIsIG51bGwsIFwiSW5wdXRzIHdpdGggaWNvbnMgbGVmdCBhbmQgcmlnaHRcIiksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJsaVwiLCBudWxsLCBcIlRleHRhcmVhXCIpLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwibGlcIiwgbnVsbCwgXCJUb2dnbGUgc3dpdGNoXCIpKSwgUmVhY3QuY3JlYXRlRWxlbWVudChIZWFkaW5nRml2ZSwgbnVsbCwgXCJUZXh0IElucHV0c1wiKSwgUmVhY3QuY3JlYXRlRWxlbWVudChCb3gsIHtcbiAgICAgICAgZGlzcGxheTogXCJncmlkXCIsXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgZ3JpZFRlbXBsYXRlQ29sdW1uczogJzFmciAxZnIgMWZyIDFmcicsXG4gICAgICAgICAgZ3JpZENvbHVtbkdhcDogMTYsXG4gICAgICAgICAgZ3JpZFJvd0dhcDogMTYsXG4gICAgICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcidcbiAgICAgICAgfVxuICAgICAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChUZXh0SW5wdXQsIHtcbiAgICAgICAgcGxhY2Vob2xkZXI6IFwiRGVmYXVsdFwiXG4gICAgICB9KSwgUmVhY3QuY3JlYXRlRWxlbWVudChUZXh0SW5wdXQsIHtcbiAgICAgICAgYm9yZGVyQ29sb3I6IFwicHJpbWFyeVwiLFxuICAgICAgICBwbGFjZWhvbGRlcjogXCJBY3RpdmVcIlxuICAgICAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVGV4dElucHV0LCB7XG4gICAgICAgIGJvcmRlckNvbG9yOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBcIlN1Y2Nlc3NcIlxuICAgICAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVGV4dElucHV0LCB7XG4gICAgICAgIGJvcmRlckNvbG9yOiBcImVycm9yXCIsXG4gICAgICAgIGNvbG9yOiBcImVycm9yXCIsXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogXCJFcnJvclwiXG4gICAgICB9KSwgUmVhY3QuY3JlYXRlRWxlbWVudChUZXh0SW5wdXQsIHtcbiAgICAgICAgYm9yZGVyQ29sb3I6IFwiZXJyb3JcIixcbiAgICAgICAgZGlzYWJsZWQ6IHRydWVcbiAgICAgIH0pLCBSZWFjdC5jcmVhdGVFbGVtZW50KFRleHRJbnB1dCwge1xuICAgICAgICBib3JkZXJSYWRpdXM6IFwibGFyZ2VcIixcbiAgICAgICAgcGxhY2Vob2xkZXI6IFwiTGFyZ2UgYm9yZGVyIHJhZGl1c1wiXG4gICAgICB9KSwgUmVhY3QuY3JlYXRlRWxlbWVudChUZXh0SW5wdXQsIHtcbiAgICAgICAgYm9yZGVyUmFkaXVzOiBcIm5vbmVcIixcbiAgICAgICAgcGxhY2Vob2xkZXI6IFwiTm8gYm9yZGVyIHJhZGl1c1wiXG4gICAgICB9KSwgUmVhY3QuY3JlYXRlRWxlbWVudChUZXh0SW5wdXQsIHtcbiAgICAgICAgYm9yZGVyUmFkaXVzOiBcIm5vbmVcIlxuICAgICAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgbnVsbCwgUmVhY3QuY3JlYXRlRWxlbWVudChGb3JtTGFiZWwsIHtcbiAgICAgICAgaHRtbEZvcjogXCJ0ZXh0SW5wdXRcIlxuICAgICAgfSwgXCJGaXJzdCBOYW1lXCIpLCBSZWFjdC5jcmVhdGVFbGVtZW50KFRleHRJbnB1dCwge1xuICAgICAgICBib3JkZXJDb2xvcjogXCJlcnJvclwiLFxuICAgICAgICBuYW1lOiBcInRleHRJbnB1dFwiXG4gICAgICB9KSwgUmVhY3QuY3JlYXRlRWxlbWVudChWYWxpZGF0aW9uTGFiZWwsIG51bGwsIFwiVGhpcyBpcyBhIHJlcXVpcmVkIGZpZWxkXCIpKSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBudWxsLCBSZWFjdC5jcmVhdGVFbGVtZW50KEZvcm1MYWJlbCwge1xuICAgICAgICBodG1sRm9yOiBcInRleHRJbnB1dDJcIlxuICAgICAgfSwgXCJQaG9uZSBOdW1iZXJcIiksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVGV4dElucHV0LCB7XG4gICAgICAgIGJvcmRlckNvbG9yOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgbmFtZTogXCJ0ZXh0SW5wdXQyXCIsXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogXCIoMDE1KSAyMzIzIDIzMjBcIlxuICAgICAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVmFsaWRhdGlvbkxhYmVsLCB7XG4gICAgICAgIGNvbG9yOiBcInN1Y2Nlc3NcIlxuICAgICAgfSwgXCJWZXJpZmllZFwiKSkpLCBSZWFjdC5jcmVhdGVFbGVtZW50KEJveCwge1xuICAgICAgICBkaXNwbGF5OiBcImdyaWRcIixcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICBncmlkVGVtcGxhdGVDb2x1bW5zOiAnMWZyIDFmciAxZnIgMWZyJyxcbiAgICAgICAgICBncmlkQ29sdW1uR2FwOiAxNixcbiAgICAgICAgICBncmlkUm93R2FwOiAxNixcbiAgICAgICAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgICAgICAgICBtYXJnaW5Ub3A6IDMyXG4gICAgICAgIH1cbiAgICAgIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgbnVsbCwgUmVhY3QuY3JlYXRlRWxlbWVudChIZWFkaW5nRml2ZSwgbnVsbCwgXCJSYWRpbyBCdXR0b25zXCIpLCBSZWFjdC5jcmVhdGVFbGVtZW50KFN0YXRlZnVsUmFkaW9CdXR0b25zLCBudWxsKSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgbnVsbCwgUmVhY3QuY3JlYXRlRWxlbWVudChIZWFkaW5nRml2ZSwgbnVsbCwgXCJDaGVja2JveGVzXCIpLCBSZWFjdC5jcmVhdGVFbGVtZW50KENoZWNrYm94ZXMsIG51bGwpKSkpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBNRFhDb250ZW50O1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5leHBvcnQgeyBNRFhDb250ZW50IGFzIGRlZmF1bHQgfTsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IE1EWFRhZyB9IGZyb20gJ0BtZHgtanMvdGFnJztcbmltcG9ydCB7IEJvZHlUZXh0LCBCb3ggfSBmcm9tICdjYWJhbmEtcmVhY3QnO1xuaW1wb3J0ICogYXMgaWNvbnMgZnJvbSAnY2FiYW5haWNvJztcblxudmFyIEljb25zID0gZnVuY3Rpb24gSWNvbnMoKSB7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KEJveCwge1xuICAgIGZvbnRTaXplOiBcImxlYWRcIixcbiAgICBkaXNwbGF5OiBcImdyaWRcIixcbiAgICBjb2xvcjogXCJkYXJrR3JleVwiLFxuICAgIHN0eWxlOiB7XG4gICAgICBncmlkVGVtcGxhdGVSb3dzOiAncmVwZWF0KDEwLCAxZnIpJyxcbiAgICAgIGdyaWRUZW1wbGF0ZUNvbHVtbnM6ICdyZXBlYXQoMTAsIDFmciknLFxuICAgICAgZ2FwOiAnMjBweCdcbiAgICB9XG4gIH0sIE9iamVjdC5rZXlzKGljb25zKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBJY29uID0gaWNvbnNba2V5XTtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChJY29uLCB7XG4gICAgICBrZXk6IGtleVxuICAgIH0pO1xuICB9KSk7XG59O1xuXG52YXIgTURYQ29udGVudCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoTURYQ29udGVudCwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gTURYQ29udGVudChwcm9wcykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNRFhDb250ZW50KTtcblxuICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKE1EWENvbnRlbnQpLmNhbGwodGhpcywgcHJvcHMpKTtcbiAgICBfdGhpcy5sYXlvdXQgPSBudWxsO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhNRFhDb250ZW50LCBbe1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICBjb21wb25lbnRzID0gX3RoaXMkcHJvcHMuY29tcG9uZW50cyxcbiAgICAgICAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfdGhpcyRwcm9wcywgW1wiY29tcG9uZW50c1wiXSk7XG5cbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KE1EWFRhZywge1xuICAgICAgICBuYW1lOiBcIndyYXBwZXJcIixcbiAgICAgICAgY29tcG9uZW50czogY29tcG9uZW50c1xuICAgICAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChNRFhUYWcsIHtcbiAgICAgICAgbmFtZTogXCJwXCIsXG4gICAgICAgIGNvbXBvbmVudHM6IGNvbXBvbmVudHNcbiAgICAgIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJhXCIsIHtcbiAgICAgICAgaWQ6IFwiSWNvbnNcIlxuICAgICAgfSkpLCBSZWFjdC5jcmVhdGVFbGVtZW50KE1EWFRhZywge1xuICAgICAgICBuYW1lOiBcImgxXCIsXG4gICAgICAgIGNvbXBvbmVudHM6IGNvbXBvbmVudHNcbiAgICAgIH0sIFwiSWNvbnNcIiksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTURYVGFnLCB7XG4gICAgICAgIG5hbWU6IFwicFwiLFxuICAgICAgICBjb21wb25lbnRzOiBjb21wb25lbnRzXG4gICAgICB9LCBcIkNhYmFuYSB1c2VzIHRoZSBcIiwgUmVhY3QuY3JlYXRlRWxlbWVudChNRFhUYWcsIHtcbiAgICAgICAgbmFtZTogXCJhXCIsXG4gICAgICAgIGNvbXBvbmVudHM6IGNvbXBvbmVudHMsXG4gICAgICAgIHBhcmVudE5hbWU6IFwicFwiLFxuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIFwiaHJlZlwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9sdWNhc3RvYnJhemlsL2NhYmFuYWljb1wiXG4gICAgICAgIH1cbiAgICAgIH0sIFwiY2FiYW5haWNvXCIpLCBcIiBsaWJyYXJ5LlwiKSwgUmVhY3QuY3JlYXRlRWxlbWVudChJY29ucywgbnVsbCkpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBNRFhDb250ZW50O1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5leHBvcnQgeyBNRFhDb250ZW50IGFzIGRlZmF1bHQgfTsiLCJleHBvcnQgdmFyIG1ha2VIYXNoTGluayA9IGZ1bmN0aW9uIG1ha2VIYXNoTGluayh0aXRsZSkge1xuICByZXR1cm4gdGl0bGUuc3BsaXQoJyAnKS5qb2luKCcnKTtcbn07IiwiZnVuY3Rpb24gX3RlbXBsYXRlT2JqZWN0MigpIHtcbiAgdmFyIGRhdGEgPSBfdGFnZ2VkVGVtcGxhdGVMaXRlcmFsKFtcIlxcbiAgbGlzdC1zdHlsZS10eXBlOiBub25lO1xcbiAgXCIsIFwiO1xcbiAgXCIsIFwiO1xcbiAgXCIsIFwiO1xcbiAgXCIsIFwiO1xcbiAgYSB7XFxuICAgIFwiLCBcIjtcXG4gICAgY29sb3I6IGluaGVyaXQ7XFxuICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG4gICAgZGlzcGxheTogYmxvY2s7XFxuXFxuICAgICY6aG92ZXIge1xcbiAgICAgIGNvbG9yOiBibGFjaztcXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuMSk7XFxuICAgIH1cXG4gIH1cXG5cIl0pO1xuXG4gIF90ZW1wbGF0ZU9iamVjdDIgPSBmdW5jdGlvbiBfdGVtcGxhdGVPYmplY3QyKCkge1xuICAgIHJldHVybiBkYXRhO1xuICB9O1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBfdGVtcGxhdGVPYmplY3QoKSB7XG4gIHZhciBkYXRhID0gX3RhZ2dlZFRlbXBsYXRlTGl0ZXJhbChbXCJcXG4gIFwiLCBcIjtcXG4gIHBhZGRpbmc6IDA7XFxuICBcIiwgXCI7XFxuXCJdKTtcblxuICBfdGVtcGxhdGVPYmplY3QgPSBmdW5jdGlvbiBfdGVtcGxhdGVPYmplY3QoKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH07XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIF90YWdnZWRUZW1wbGF0ZUxpdGVyYWwoc3RyaW5ncywgcmF3KSB7IGlmICghcmF3KSB7IHJhdyA9IHN0cmluZ3Muc2xpY2UoMCk7IH0gcmV0dXJuIE9iamVjdC5mcmVlemUoT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoc3RyaW5ncywgeyByYXc6IHsgdmFsdWU6IE9iamVjdC5mcmVlemUocmF3KSB9IH0pKTsgfVxuXG5pbXBvcnQgeyBCb3gsIENhcHRpb25UZXh0IH0gZnJvbSAnY2FiYW5hLXJlYWN0JztcbmltcG9ydCB7IGJvcmRlckJvdHRvbSwgYm9yZGVyQ29sb3IsIGNvbG9yLCBmb250RmFtaWx5LCBmb250V2VpZ2h0LCBzcGFjZSB9IGZyb20gJ3N0eWxlZC1zeXN0ZW0nO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBzdHlsZWQgZnJvbSAnc3R5bGVkLWNvbXBvbmVudHMnO1xuaW1wb3J0IHsgSGFzaExpbmsgYXMgTGluayB9IGZyb20gJ3JlYWN0LXJvdXRlci1oYXNoLWxpbmsnO1xuaW1wb3J0IHsgbWFrZUhhc2hMaW5rIH0gZnJvbSAnLi4vc2VydmljZXMnO1xudmFyIExpc3QgPSBzdHlsZWQudWwoX3RlbXBsYXRlT2JqZWN0KCksIGZvbnRGYW1pbHksIHNwYWNlKTtcbnZhciBMaXN0SXRlbSA9IHN0eWxlZC5saShfdGVtcGxhdGVPYmplY3QyKCksIGZvbnRXZWlnaHQsIGJvcmRlckJvdHRvbSwgYm9yZGVyQ29sb3IsIGNvbG9yLCBzcGFjZSk7XG5MaXN0SXRlbS5kZWZhdWx0UHJvcHMgPSB7XG4gIHA6IDFcbn07XG52YXIgaXRlbXMgPSBbJ0F2YXRhcnMnLCAnQnV0dG9ucycsICdDYXJkcycsICdDaGlwcycsICdGb3JtcycsICdJY29ucycsICdOb3RpZmljYXRpb24gQmFyJywgJ1BhZ2luYXRpb24nLCAnUHJvZ3Jlc3MgQmFyJywgJ1RhYnMnLCAnVGFncycsICdUZXh0JywgJ1Rvb2x0aXBzJ107XG52YXIgdG9kb0l0ZW1zID0gWydEYXRlUGlja2VycycsICdEcm9wZG93bnMnLCAnTWFwJywgJ01lbnVzJywgJ01vZGFsJywgJ1NsaWRlcnMnLCAnVGFibGVzJywgJ1ZpZGVvIFBsYXllciddO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRG9jc05hdigpIHtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQm94LCB7XG4gICAgcG9zaXRpb246IFwiZml4ZWRcIixcbiAgICB3aWR0aDogMjQ2LFxuICAgIHB0OiAyLFxuICAgIG1yOiAyLFxuICAgIGhlaWdodDogXCIxMDAlXCIsXG4gICAgY3NzOiBcIm92ZXJmbG93OiBhdXRvXCJcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChDYXB0aW9uVGV4dCwge1xuICAgIGZvbnRXZWlnaHQ6IFwiYm9sZFwiLFxuICAgIHB4OiAxLFxuICAgIGNvbG9yOiBcImxpZ2h0R3JleVwiXG4gIH0sIFwiQ29tcG9uZW50c1wiKSwgUmVhY3QuY3JlYXRlRWxlbWVudChMaXN0LCB7XG4gICAgZm9udEZhbWlseTogXCJkZWZhdWx0XCIsXG4gICAgbTogMFxuICB9LCBpdGVtcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChMaXN0SXRlbSwge1xuICAgICAga2V5OiBpdGVtLFxuICAgICAgY29sb3I6IFwiZ3JleVwiXG4gICAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChMaW5rLCB7XG4gICAgICB0bzogXCIjXCIuY29uY2F0KG1ha2VIYXNoTGluayhpdGVtKSlcbiAgICB9LCBpdGVtKSk7XG4gIH0pKSwgUmVhY3QuY3JlYXRlRWxlbWVudChMaXN0LCB7XG4gICAgZm9udEZhbWlseTogXCJkZWZhdWx0XCIsXG4gICAgbTogMCxcbiAgICBtdDogMlxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KENhcHRpb25UZXh0LCB7XG4gICAgZm9udFdlaWdodDogXCJib2xkXCIsXG4gICAgcHg6IDEsXG4gICAgY29sb3I6IFwiZ3JleVwiXG4gIH0sIFwiTm90IHlldCBkb25lOlwiKSwgdG9kb0l0ZW1zLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KExpc3RJdGVtLCB7XG4gICAgICBrZXk6IGl0ZW0sXG4gICAgICBjb2xvcjogXCJncmV5XCJcbiAgICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KExpbmssIHtcbiAgICAgIHRvOiBcIiNcIi5jb25jYXQobWFrZUhhc2hMaW5rKGl0ZW0pKVxuICAgIH0sIGl0ZW0pKTtcbiAgfSkpKTtcbn0iLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IE1EWFRhZyB9IGZyb20gJ0BtZHgtanMvdGFnJztcbmltcG9ydCB7IE5vdGlmaWNhdGlvbkJhciB9IGZyb20gJ2NhYmFuYS1yZWFjdCc7XG5cbnZhciBNRFhDb250ZW50ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhNRFhDb250ZW50LCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBNRFhDb250ZW50KHByb3BzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1EWENvbnRlbnQpO1xuXG4gICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoTURYQ29udGVudCkuY2FsbCh0aGlzLCBwcm9wcykpO1xuICAgIF90aGlzLmxheW91dCA9IG51bGw7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKE1EWENvbnRlbnQsIFt7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIGNvbXBvbmVudHMgPSBfdGhpcyRwcm9wcy5jb21wb25lbnRzLFxuICAgICAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF90aGlzJHByb3BzLCBbXCJjb21wb25lbnRzXCJdKTtcblxuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTURYVGFnLCB7XG4gICAgICAgIG5hbWU6IFwid3JhcHBlclwiLFxuICAgICAgICBjb21wb25lbnRzOiBjb21wb25lbnRzXG4gICAgICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KE1EWFRhZywge1xuICAgICAgICBuYW1lOiBcInBcIixcbiAgICAgICAgY29tcG9uZW50czogY29tcG9uZW50c1xuICAgICAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImFcIiwge1xuICAgICAgICBpZDogXCJOb3RpZmljYXRpb25CYXJcIlxuICAgICAgfSkpLCBSZWFjdC5jcmVhdGVFbGVtZW50KE1EWFRhZywge1xuICAgICAgICBuYW1lOiBcImgxXCIsXG4gICAgICAgIGNvbXBvbmVudHM6IGNvbXBvbmVudHNcbiAgICAgIH0sIFwiTm90aWZpY2F0aW9uQmFyXCIpLCBSZWFjdC5jcmVhdGVFbGVtZW50KE5vdGlmaWNhdGlvbkJhciwge1xuICAgICAgICBtYjogMSxcbiAgICAgICAgY29udGVudDogXCJPb3BzISBUaGVyZSBzZWVtcyB0byBiZSBhbiBlcnJvclwiLFxuICAgICAgICBiZzogXCJlcnJvclwiLFxuICAgICAgICBjb2xvcjogXCJ3aGl0ZVwiXG4gICAgICB9KSwgUmVhY3QuY3JlYXRlRWxlbWVudChOb3RpZmljYXRpb25CYXIsIHtcbiAgICAgICAgbWI6IDEsXG4gICAgICAgIGNvbnRlbnQ6IFwiSGF2ZSB5b3Ugc2F2ZWQgeW91ciB3b3JrP1wiLFxuICAgICAgICBiZzogXCJ3YXJuaW5nXCIsXG4gICAgICAgIGNvbG9yOiBcImJsYWNrXCJcbiAgICAgIH0pLCBSZWFjdC5jcmVhdGVFbGVtZW50KE5vdGlmaWNhdGlvbkJhciwge1xuICAgICAgICBtYjogMSxcbiAgICAgICAgY29udGVudDogXCJPaCB5ZXMhIFNldHRpbmdzIGhhdmUgYmVlbiBzYXZlZFwiLFxuICAgICAgICBiZzogXCJzdWNjZXNzXCIsXG4gICAgICAgIGNvbG9yOiBcIndoaXRlXCJcbiAgICAgIH0pLCBSZWFjdC5jcmVhdGVFbGVtZW50KE5vdGlmaWNhdGlvbkJhciwge1xuICAgICAgICBtYjogMSxcbiAgICAgICAgY29udGVudDogXCJPaCB5ZXMhIFNldHRpbmdzIGhhdmUgYmVlbiBzYXZlZFwiLFxuICAgICAgICBiZzogXCJwcmltYXJ5XCIsXG4gICAgICAgIGNvbG9yOiBcIndoaXRlXCIsXG4gICAgICAgIGRpc21pc3NhYmxlOiBmYWxzZVxuICAgICAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTm90aWZpY2F0aW9uQmFyLCB7XG4gICAgICAgIGJveFNoYWRvdzogMTAwLFxuICAgICAgICBtOiAzLFxuICAgICAgICBpY29uOiBmYWxzZSxcbiAgICAgICAgZm9udFNpemU6IFwic21hbGxcIixcbiAgICAgICAgY29udGVudDogXCJXM1NjaG9vbHMgaXMgb3B0aW1pemVkIGZvciBsZWFybmluZywgdGVzdGluZywgYW5kIHRyYWluaW5nLiBFeGFtcGxlcyBtaWdodCBiZSBzaW1wbGlmaWVkIHRvIGltcHJvdmUgcmVhZGluZyBhbmQgYmFzaWMgdW5kZXJzdGFuZGluZy4gVHV0b3JpYWxzLCByZWZlcmVuY2VzLCBhbmQgZXhhbXBsZXMgYXJlIGNvbnN0YW50bHkgcmV2aWV3ZWQgdG8gYXZvaWQgZXJyb3JzLCBidXQgd2UgY2Fubm90IHdhcnJhbnQgZnVsbCBjb3JyZWN0bmVzcyBvZiBhbGwgY29udGVudC4gV2hpbGUgdXNpbmcgdGhpcyBzaXRlLCB5b3UgYWdyZWUgdG8gaGF2ZSByZWFkIGFuZCBhY2NlcHRlZCBvdXIgdGVybXMgb2YgdXNlLCBjb29raWUgYW5kIHByaXZhY3kgcG9saWN5LiBDb3B5cmlnaHQgMTk5OS0yMDE4IGJ5IFJlZnNuZXMgRGF0YS4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cIixcbiAgICAgICAgYmc6IFwic3VjY2Vzc1wiLFxuICAgICAgICBjb2xvcjogXCJ3aGl0ZVwiXG4gICAgICB9KSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE1EWENvbnRlbnQ7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbmV4cG9ydCB7IE1EWENvbnRlbnQgYXMgZGVmYXVsdCB9OyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7IHZhciBrZXksIGk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgdmFyIGtleSwgaTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgTURYVGFnIH0gZnJvbSAnQG1keC1qcy90YWcnO1xuaW1wb3J0IHsgUGFnaW5hdGlvbiB9IGZyb20gJ2NhYmFuYS1yZWFjdCc7XG5cbnZhciBNRFhDb250ZW50ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhNRFhDb250ZW50LCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBNRFhDb250ZW50KHByb3BzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1EWENvbnRlbnQpO1xuXG4gICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoTURYQ29udGVudCkuY2FsbCh0aGlzLCBwcm9wcykpO1xuICAgIF90aGlzLmxheW91dCA9IG51bGw7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKE1EWENvbnRlbnQsIFt7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIGNvbXBvbmVudHMgPSBfdGhpcyRwcm9wcy5jb21wb25lbnRzLFxuICAgICAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF90aGlzJHByb3BzLCBbXCJjb21wb25lbnRzXCJdKTtcblxuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTURYVGFnLCB7XG4gICAgICAgIG5hbWU6IFwid3JhcHBlclwiLFxuICAgICAgICBjb21wb25lbnRzOiBjb21wb25lbnRzXG4gICAgICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KE1EWFRhZywge1xuICAgICAgICBuYW1lOiBcInBcIixcbiAgICAgICAgY29tcG9uZW50czogY29tcG9uZW50c1xuICAgICAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImFcIiwge1xuICAgICAgICBpZDogXCJQYWdpbmF0aW9uXCJcbiAgICAgIH0pKSwgUmVhY3QuY3JlYXRlRWxlbWVudChNRFhUYWcsIHtcbiAgICAgICAgbmFtZTogXCJoMVwiLFxuICAgICAgICBjb21wb25lbnRzOiBjb21wb25lbnRzXG4gICAgICB9LCBcIlBhZ2luYXRpb25cIiksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUGFnaW5hdGlvbiwgbnVsbCksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUGFnaW5hdGlvbiwge1xuICAgICAgICBzaXplOiAxNlxuICAgICAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUGFnaW5hdGlvbiwge1xuICAgICAgICBzaXplOiAzMlxuICAgICAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUGFnaW5hdGlvbiwge1xuICAgICAgICB0eXBlOiBcIm51bWJlcnNcIlxuICAgICAgfSkpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBNRFhDb250ZW50O1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5leHBvcnQgeyBNRFhDb250ZW50IGFzIGRlZmF1bHQgfTsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuaW1wb3J0IHsgQm94LCBQcm9ncmVzc0JhciB9IGZyb20gJ2NhYmFuYS1yZWFjdCc7XG5pbXBvcnQgUmVhY3QsIHsgRnJhZ21lbnQgfSBmcm9tICdyZWFjdCc7XG5cbnZhciBTbGlkZXIgPSBmdW5jdGlvbiBTbGlkZXIoX3JlZikge1xuICB2YXIgb25DaGFuZ2UgPSBfcmVmLm9uQ2hhbmdlLFxuICAgICAgYW1vdW50ID0gX3JlZi5hbW91bnQ7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIiwge1xuICAgIHR5cGU6IFwicmFuZ2VcIixcbiAgICBzdHlsZToge1xuICAgICAgd2lkdGg6ICcxMDAlJ1xuICAgIH0sXG4gICAgc3RlcDogXCIxXCIsXG4gICAgdmFsdWU6IGFtb3VudCxcbiAgICBvbkNoYW5nZTogb25DaGFuZ2UsXG4gICAgbGlzdDogXCJ0aWNrbWFya3NcIlxuICB9KSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImRhdGFsaXN0XCIsIHtcbiAgICBpZDogXCJ0aWNrbWFya3NcIlxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIsIHtcbiAgICB2YWx1ZTogXCIwXCJcbiAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIiwge1xuICAgIHZhbHVlOiBcIjEwXCJcbiAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIiwge1xuICAgIHZhbHVlOiBcIjIwXCJcbiAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIiwge1xuICAgIHZhbHVlOiBcIjMwXCJcbiAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIiwge1xuICAgIHZhbHVlOiBcIjQwXCJcbiAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIiwge1xuICAgIHZhbHVlOiBcIjUwXCJcbiAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIiwge1xuICAgIHZhbHVlOiBcIjYwXCJcbiAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIiwge1xuICAgIHZhbHVlOiBcIjcwXCJcbiAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIiwge1xuICAgIHZhbHVlOiBcIjgwXCJcbiAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIiwge1xuICAgIHZhbHVlOiBcIjkwXCJcbiAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIiwge1xuICAgIHZhbHVlOiBcIjEwMFwiXG4gIH0pKSk7XG59O1xuXG52YXIgU3RhdGVmdWxFeGFtcGxlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhTdGF0ZWZ1bEV4YW1wbGUsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFN0YXRlZnVsRXhhbXBsZSgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3RhdGVmdWxFeGFtcGxlKTtcblxuICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKFN0YXRlZnVsRXhhbXBsZSkuY2FsbCh0aGlzKSk7XG4gICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICBhbW91bnQ6IDYyXG4gICAgfTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU3RhdGVmdWxFeGFtcGxlLCBbe1xuICAgIGtleTogXCJvbkNoYW5nZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkNoYW5nZShldmVudCkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGFtb3VudDogcGFyc2VJbnQoZXZlbnQudGFyZ2V0LnZhbHVlLCAxMClcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIGFtb3VudCA9IHRoaXMuc3RhdGUuYW1vdW50O1xuICAgICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICBpbm5lckJnID0gX3RoaXMkcHJvcHMuaW5uZXJCZyxcbiAgICAgICAgICBvdXRlckJnID0gX3RoaXMkcHJvcHMub3V0ZXJCZyxcbiAgICAgICAgICBib3JkZXJSYWRpdXMgPSBfdGhpcyRwcm9wcy5ib3JkZXJSYWRpdXMsXG4gICAgICAgICAgcCA9IF90aGlzJHByb3BzLnAsXG4gICAgICAgICAgZm9udFNpemUgPSBfdGhpcyRwcm9wcy5mb250U2l6ZSxcbiAgICAgICAgICBzaG93TnVtYmVyID0gX3RoaXMkcHJvcHMuc2hvd051bWJlcixcbiAgICAgICAgICBtaW5IZWlnaHQgPSBfdGhpcyRwcm9wcy5taW5IZWlnaHQsXG4gICAgICAgICAgY29sb3IgPSBfdGhpcyRwcm9wcy5jb2xvcjtcbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KEJveCwge1xuICAgICAgICBtdDogM1xuICAgICAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChTbGlkZXIsIHtcbiAgICAgICAgb25DaGFuZ2U6IHRoaXMub25DaGFuZ2UuYmluZCh0aGlzKSxcbiAgICAgICAgYW1vdW50OiBhbW91bnRcbiAgICAgIH0pLCBSZWFjdC5jcmVhdGVFbGVtZW50KFByb2dyZXNzQmFyLCB7XG4gICAgICAgIGNvbG9yOiBjb2xvcixcbiAgICAgICAgcDogcCxcbiAgICAgICAgaW5uZXJCZzogaW5uZXJCZyxcbiAgICAgICAgb3V0ZXJCZzogb3V0ZXJCZyxcbiAgICAgICAgYW1vdW50OiBhbW91bnQsXG4gICAgICAgIGJvcmRlclJhZGl1czogYm9yZGVyUmFkaXVzLFxuICAgICAgICBmb250U2l6ZTogZm9udFNpemUsXG4gICAgICAgIHNob3dOdW1iZXI6IHNob3dOdW1iZXIsXG4gICAgICAgIG1pbkhlaWdodDogbWluSGVpZ2h0XG4gICAgICB9KSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFN0YXRlZnVsRXhhbXBsZTtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuZXhwb3J0IHsgU3RhdGVmdWxFeGFtcGxlLCBTbGlkZXIgfTsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IE1EWFRhZyB9IGZyb20gJ0BtZHgtanMvdGFnJztcbmltcG9ydCB7IEJveCwgUHJvZ3Jlc3NCYXIgfSBmcm9tICdjYWJhbmEtcmVhY3QnO1xuaW1wb3J0IHsgU3RhdGVmdWxFeGFtcGxlLCBTbGlkZXIgfSBmcm9tICcuL2hlbHBlcnMuanMnO1xuXG52YXIgTURYQ29udGVudCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoTURYQ29udGVudCwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gTURYQ29udGVudChwcm9wcykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNRFhDb250ZW50KTtcblxuICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKE1EWENvbnRlbnQpLmNhbGwodGhpcywgcHJvcHMpKTtcbiAgICBfdGhpcy5sYXlvdXQgPSBudWxsO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhNRFhDb250ZW50LCBbe1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICBjb21wb25lbnRzID0gX3RoaXMkcHJvcHMuY29tcG9uZW50cyxcbiAgICAgICAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfdGhpcyRwcm9wcywgW1wiY29tcG9uZW50c1wiXSk7XG5cbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KE1EWFRhZywge1xuICAgICAgICBuYW1lOiBcIndyYXBwZXJcIixcbiAgICAgICAgY29tcG9uZW50czogY29tcG9uZW50c1xuICAgICAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChNRFhUYWcsIHtcbiAgICAgICAgbmFtZTogXCJwXCIsXG4gICAgICAgIGNvbXBvbmVudHM6IGNvbXBvbmVudHNcbiAgICAgIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJhXCIsIHtcbiAgICAgICAgaWQ6IFwiUHJvZ3Jlc3NCYXJcIlxuICAgICAgfSkpLCBSZWFjdC5jcmVhdGVFbGVtZW50KE1EWFRhZywge1xuICAgICAgICBuYW1lOiBcImgxXCIsXG4gICAgICAgIGNvbXBvbmVudHM6IGNvbXBvbmVudHNcbiAgICAgIH0sIFwiUHJvZ3Jlc3NCYXJcIiksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTURYVGFnLCB7XG4gICAgICAgIG5hbWU6IFwicFwiLFxuICAgICAgICBjb21wb25lbnRzOiBjb21wb25lbnRzXG4gICAgICB9LCBcIk5vdGU6IHRoZSBzbGlkZXJzIGluY2x1ZGVkIGJlbG93IGFyZSB0byBzaW11bGF0ZSB0aGUgY2hhbmdpbmcgcHJvZ3Jlc3Mgb2YgdGhlIFwiLCBSZWFjdC5jcmVhdGVFbGVtZW50KE1EWFRhZywge1xuICAgICAgICBuYW1lOiBcImlubGluZUNvZGVcIixcbiAgICAgICAgY29tcG9uZW50czogY29tcG9uZW50cyxcbiAgICAgICAgcGFyZW50TmFtZTogXCJwXCJcbiAgICAgIH0sIFwiUHJvZ3Jlc3NCYXJcIiksIFwiLlwiKSwgUmVhY3QuY3JlYXRlRWxlbWVudChCb3gsIHtcbiAgICAgICAgd2lkdGg6IDEgLyAzXG4gICAgICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFN0YXRlZnVsRXhhbXBsZSwge1xuICAgICAgICBpbm5lckJnOiBcInByaW1hcnlcIlxuICAgICAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoU3RhdGVmdWxFeGFtcGxlLCB7XG4gICAgICAgIGlubmVyQmc6IFwidGVydGlhcnlcIixcbiAgICAgICAgYm9yZGVyUmFkaXVzOiBcImxhcmdlXCJcbiAgICAgIH0pLCBSZWFjdC5jcmVhdGVFbGVtZW50KFN0YXRlZnVsRXhhbXBsZSwge1xuICAgICAgICBpbm5lckJnOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgY29sb3I6IFwid2hpdGVcIixcbiAgICAgICAgcDogMSxcbiAgICAgICAgZm9udFNpemU6IFwiYm9keVwiLFxuICAgICAgICBib3JkZXJSYWRpdXM6IFwibGFyZ2VcIlxuICAgICAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoU3RhdGVmdWxFeGFtcGxlLCB7XG4gICAgICAgIGlubmVyQmc6IFwicHJpbWFyeVwiLFxuICAgICAgICBwOiAxLFxuICAgICAgICBib3JkZXJSYWRpdXM6IFwibm9uZVwiXG4gICAgICB9KSwgUmVhY3QuY3JlYXRlRWxlbWVudChTdGF0ZWZ1bEV4YW1wbGUsIHtcbiAgICAgICAgaW5uZXJCZzogXCJwcmltYXJ5XCIsXG4gICAgICAgIGZvbnRTaXplOiBcInViZXJcIlxuICAgICAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoU3RhdGVmdWxFeGFtcGxlLCB7XG4gICAgICAgIGlubmVyQmc6IFwicHJpbWFyeVwiLFxuICAgICAgICBzaG93TnVtYmVyOiBmYWxzZSxcbiAgICAgICAgbWluSGVpZ2h0OiAyMFxuICAgICAgfSkpKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTURYQ29udGVudDtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuZXhwb3J0IHsgTURYQ29udGVudCBhcyBkZWZhdWx0IH07IiwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyB2YXIga2V5LCBpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBNRFhUYWcgfSBmcm9tICdAbWR4LWpzL3RhZyc7XG5pbXBvcnQgeyBUYWJzLCBIZWFkaW5nVHdvIH0gZnJvbSAnY2FiYW5hLXJlYWN0JztcbmltcG9ydCB7IEljb25WaWRlbywgSWNvbkNhcnQsIEljb25DYW1lcmEgfSBmcm9tICdjYWJhbmFpY28nO1xuXG52YXIgTURYQ29udGVudCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoTURYQ29udGVudCwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gTURYQ29udGVudChwcm9wcykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNRFhDb250ZW50KTtcblxuICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKE1EWENvbnRlbnQpLmNhbGwodGhpcywgcHJvcHMpKTtcbiAgICBfdGhpcy5sYXlvdXQgPSBudWxsO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhNRFhDb250ZW50LCBbe1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICBjb21wb25lbnRzID0gX3RoaXMkcHJvcHMuY29tcG9uZW50cyxcbiAgICAgICAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfdGhpcyRwcm9wcywgW1wiY29tcG9uZW50c1wiXSk7XG5cbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KE1EWFRhZywge1xuICAgICAgICBuYW1lOiBcIndyYXBwZXJcIixcbiAgICAgICAgY29tcG9uZW50czogY29tcG9uZW50c1xuICAgICAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChNRFhUYWcsIHtcbiAgICAgICAgbmFtZTogXCJwXCIsXG4gICAgICAgIGNvbXBvbmVudHM6IGNvbXBvbmVudHNcbiAgICAgIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJhXCIsIHtcbiAgICAgICAgaWQ6IFwiVGFic1wiXG4gICAgICB9KSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTURYVGFnLCB7XG4gICAgICAgIG5hbWU6IFwiaDFcIixcbiAgICAgICAgY29tcG9uZW50czogY29tcG9uZW50c1xuICAgICAgfSwgXCJUYWJzXCIpLCBSZWFjdC5jcmVhdGVFbGVtZW50KFRhYnMsIG51bGwsIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICBsYWJlbDogXCJOZXdzXCJcbiAgICAgIH0sIFwiU2VlIHlhIGxhdGVyLCBcIiwgUmVhY3QuY3JlYXRlRWxlbWVudChcImVtXCIsIG51bGwsIFwiQWxsaWdhdG9yXCIpLCBcIiFcIiksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICBsYWJlbDogXCJTdG9yZVwiXG4gICAgICB9LCBcIkFmdGVyICd3aGlsZSwgXCIsIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJlbVwiLCBudWxsLCBcIkNyb2NvZGlsZVwiKSwgXCIhXCIpLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgbGFiZWw6IFwiVmlkZW9zXCJcbiAgICAgIH0sIFwiTm90aGluZyB0byBzZWUgaGVyZSwgdGhpcyB0YWIgaXMgXCIsIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJlbVwiLCBudWxsLCBcImV4dGluY3RcIiksIFwiIVwiKSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgIGxhYmVsOiBcIlBob3Rvc1wiXG4gICAgICB9LCBcIk5vdGhpbmcgdG8gc2VlIGhlcmUsIHRoaXMgdGFiIGlzIFwiLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZW1cIiwgbnVsbCwgXCJleHRpbmN0XCIpLCBcIiFcIikpLCBSZWFjdC5jcmVhdGVFbGVtZW50KEhlYWRpbmdUd28sIHtcbiAgICAgICAgZm9udFNpemU6IFwiaDVcIixcbiAgICAgICAgbXQ6IDZcbiAgICAgIH0sIFwiV2l0aCBJY29uXCIpLCBSZWFjdC5jcmVhdGVFbGVtZW50KFRhYnMsIG51bGwsIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICBsYWJlbDogXCJTdG9yZVwiLFxuICAgICAgICB0YWJJY29uOiBSZWFjdC5jcmVhdGVFbGVtZW50KEljb25DYXJ0LCBudWxsKVxuICAgICAgfSwgXCJTaG9wcGluZyBjYXJ0IVwiKSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgIGxhYmVsOiBcIlZpZGVvc1wiLFxuICAgICAgICB0YWJJY29uOiBSZWFjdC5jcmVhdGVFbGVtZW50KEljb25WaWRlbywgbnVsbClcbiAgICAgIH0sIFwiQ2hlY2sgb3V0IHZpZGVvc1wiKSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgIGxhYmVsOiBcIlBob3Rvc1wiLFxuICAgICAgICB0YWJJY29uOiBSZWFjdC5jcmVhdGVFbGVtZW50KEljb25DYW1lcmEsIG51bGwpXG4gICAgICB9LCBcIlNlZSBhbGwgcGhvdG9zXCIpKSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE1EWENvbnRlbnQ7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbmV4cG9ydCB7IE1EWENvbnRlbnQgYXMgZGVmYXVsdCB9OyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7IHZhciBrZXksIGk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgdmFyIGtleSwgaTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgTURYVGFnIH0gZnJvbSAnQG1keC1qcy90YWcnO1xuaW1wb3J0IHsgQm9keVRleHQsIENhcHRpb25UZXh0LCBIZWFkaW5nRml2ZSwgSGVhZGluZ0ZvdXIsIEhlYWRpbmdPbmUsIEhlYWRpbmdUaHJlZSwgSGVhZGluZ1R3bywgSGVyb1RleHQsIExlYWRUZXh0LCBTbWFsbFRleHQsIFRpbnlUZXh0LCBVYmVyVGV4dCB9IGZyb20gJ2NhYmFuYS1yZWFjdCc7XG5cbnZhciBDb250ZW50ID0gZnVuY3Rpb24gQ29udGVudChfcmVmKSB7XG4gIHZhciBmb250RmFtaWx5ID0gX3JlZi5mb250RmFtaWx5O1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBudWxsLCBSZWFjdC5jcmVhdGVFbGVtZW50KFViZXJUZXh0LCB7XG4gICAgZm9udFdlaWdodDogXCJib2xkXCIsXG4gICAgZm9udEZhbWlseTogZm9udEZhbWlseVxuICB9LCBcIlViZXJcIiksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVWJlclRleHQsIHtcbiAgICBmb250RmFtaWx5OiBmb250RmFtaWx5XG4gIH0sIFwiVWJlclwiKSwgUmVhY3QuY3JlYXRlRWxlbWVudChIZXJvVGV4dCwge1xuICAgIGZvbnRXZWlnaHQ6IFwiYm9sZFwiLFxuICAgIGZvbnRGYW1pbHk6IGZvbnRGYW1pbHlcbiAgfSwgXCJIZXJvXCIpLCBSZWFjdC5jcmVhdGVFbGVtZW50KEhlcm9UZXh0LCB7XG4gICAgZm9udEZhbWlseTogZm9udEZhbWlseVxuICB9LCBcIkhlcm9cIiksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSGVhZGluZ09uZSwge1xuICAgIGZvbnRXZWlnaHQ6IFwiYm9sZFwiLFxuICAgIGZvbnRGYW1pbHk6IGZvbnRGYW1pbHlcbiAgfSwgXCJIMSBIZWFkaW5nXCIpLCBSZWFjdC5jcmVhdGVFbGVtZW50KEhlYWRpbmdPbmUsIHtcbiAgICBmb250RmFtaWx5OiBmb250RmFtaWx5XG4gIH0sIFwiSDEgSGVhZGluZ1wiKSwgUmVhY3QuY3JlYXRlRWxlbWVudChIZWFkaW5nVHdvLCB7XG4gICAgZm9udFdlaWdodDogXCJib2xkXCIsXG4gICAgZm9udEZhbWlseTogZm9udEZhbWlseVxuICB9LCBcIkgyIEhlYWRpbmdcIiksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSGVhZGluZ1R3bywge1xuICAgIGZvbnRGYW1pbHk6IGZvbnRGYW1pbHlcbiAgfSwgXCJIMiBIZWFkaW5nXCIpLCBSZWFjdC5jcmVhdGVFbGVtZW50KEhlYWRpbmdUaHJlZSwge1xuICAgIGZvbnRXZWlnaHQ6IFwiYm9sZFwiLFxuICAgIGZvbnRGYW1pbHk6IGZvbnRGYW1pbHlcbiAgfSwgXCJIMyBIZWFkaW5nXCIpLCBSZWFjdC5jcmVhdGVFbGVtZW50KEhlYWRpbmdUaHJlZSwge1xuICAgIGZvbnRGYW1pbHk6IGZvbnRGYW1pbHlcbiAgfSwgXCJIMyBIZWFkaW5nXCIpLCBSZWFjdC5jcmVhdGVFbGVtZW50KEhlYWRpbmdGb3VyLCB7XG4gICAgZm9udFdlaWdodDogXCJib2xkXCIsXG4gICAgZm9udEZhbWlseTogZm9udEZhbWlseVxuICB9LCBcIkg0IEhlYWRpbmdcIiksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSGVhZGluZ0ZvdXIsIHtcbiAgICBmb250RmFtaWx5OiBmb250RmFtaWx5XG4gIH0sIFwiSDQgSGVhZGluZ1wiKSwgUmVhY3QuY3JlYXRlRWxlbWVudChIZWFkaW5nRml2ZSwge1xuICAgIGZvbnRXZWlnaHQ6IFwiYm9sZFwiLFxuICAgIGZvbnRGYW1pbHk6IGZvbnRGYW1pbHlcbiAgfSwgXCJINSBIZWFkaW5nXCIpLCBSZWFjdC5jcmVhdGVFbGVtZW50KEhlYWRpbmdGaXZlLCB7XG4gICAgZm9udEZhbWlseTogZm9udEZhbWlseVxuICB9LCBcIkg1IEhlYWRpbmdcIiksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTGVhZFRleHQsIHtcbiAgICBmb250V2VpZ2h0OiBcImJvbGRcIixcbiAgICBmb250RmFtaWx5OiBmb250RmFtaWx5XG4gIH0sIFwiTGVhZFwiKSwgUmVhY3QuY3JlYXRlRWxlbWVudChMZWFkVGV4dCwge1xuICAgIGZvbnRGYW1pbHk6IGZvbnRGYW1pbHlcbiAgfSwgXCJMZWFkXCIpLCBSZWFjdC5jcmVhdGVFbGVtZW50KEJvZHlUZXh0LCB7XG4gICAgZm9udFdlaWdodDogXCJib2xkXCIsXG4gICAgZm9udEZhbWlseTogZm9udEZhbWlseVxuICB9LCBcIkJvZHlcIiksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQm9keVRleHQsIHtcbiAgICBmb250RmFtaWx5OiBmb250RmFtaWx5XG4gIH0sIFwiQm9keVwiKSwgUmVhY3QuY3JlYXRlRWxlbWVudChTbWFsbFRleHQsIHtcbiAgICBmb250V2VpZ2h0OiBcImJvbGRcIixcbiAgICBmb250RmFtaWx5OiBmb250RmFtaWx5XG4gIH0sIFwiU21hbGxcIiksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoU21hbGxUZXh0LCB7XG4gICAgZm9udEZhbWlseTogZm9udEZhbWlseVxuICB9LCBcIlNtYWxsXCIpLCBSZWFjdC5jcmVhdGVFbGVtZW50KENhcHRpb25UZXh0LCB7XG4gICAgZm9udFdlaWdodDogXCJib2xkXCIsXG4gICAgZm9udEZhbWlseTogZm9udEZhbWlseVxuICB9LCBcIkNhcHRpb25cIiksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ2FwdGlvblRleHQsIHtcbiAgICBmb250RmFtaWx5OiBmb250RmFtaWx5XG4gIH0sIFwiQ2FwdGlvblwiKSwgUmVhY3QuY3JlYXRlRWxlbWVudChUaW55VGV4dCwge1xuICAgIGZvbnRXZWlnaHQ6IFwiYm9sZFwiLFxuICAgIGZvbnRGYW1pbHk6IGZvbnRGYW1pbHlcbiAgfSwgXCJUaW55XCIpLCBSZWFjdC5jcmVhdGVFbGVtZW50KFRpbnlUZXh0LCB7XG4gICAgZm9udEZhbWlseTogZm9udEZhbWlseVxuICB9LCBcIlRpbnlcIikpO1xufTtcblxudmFyIE1EWENvbnRlbnQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKE1EWENvbnRlbnQsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIE1EWENvbnRlbnQocHJvcHMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTURYQ29udGVudCk7XG5cbiAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihNRFhDb250ZW50KS5jYWxsKHRoaXMsIHByb3BzKSk7XG4gICAgX3RoaXMubGF5b3V0ID0gbnVsbDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTURYQ29udGVudCwgW3tcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgY29tcG9uZW50cyA9IF90aGlzJHByb3BzLmNvbXBvbmVudHMsXG4gICAgICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3RoaXMkcHJvcHMsIFtcImNvbXBvbmVudHNcIl0pO1xuXG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChNRFhUYWcsIHtcbiAgICAgICAgbmFtZTogXCJ3cmFwcGVyXCIsXG4gICAgICAgIGNvbXBvbmVudHM6IGNvbXBvbmVudHNcbiAgICAgIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTURYVGFnLCB7XG4gICAgICAgIG5hbWU6IFwicFwiLFxuICAgICAgICBjb21wb25lbnRzOiBjb21wb25lbnRzXG4gICAgICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYVwiLCB7XG4gICAgICAgIGlkOiBcIlRleHRcIlxuICAgICAgfSkpLCBSZWFjdC5jcmVhdGVFbGVtZW50KE1EWFRhZywge1xuICAgICAgICBuYW1lOiBcImgxXCIsXG4gICAgICAgIGNvbXBvbmVudHM6IGNvbXBvbmVudHNcbiAgICAgIH0sIFwiVGV4dFwiKSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgICAgIGZsZXhXcmFwOiAnd3JhcCdcbiAgICAgICAgfVxuICAgICAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBudWxsLCBSZWFjdC5jcmVhdGVFbGVtZW50KEhlYWRpbmdPbmUsIHtcbiAgICAgICAgY29sb3I6IFwic2Vjb25kYXJ5XCJcbiAgICAgIH0sIFwiRm9udCBGYW1pbHkgIzFcIiksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29udGVudCwgbnVsbCkpLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIG51bGwsIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSGVhZGluZ09uZSwge1xuICAgICAgICBjb2xvcjogXCJwcmltYXJ5XCJcbiAgICAgIH0sIFwiRm9udCBGYW1pbHkgIzJcIiksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29udGVudCwge1xuICAgICAgICBmb250RmFtaWx5OiBcImFsdFwiXG4gICAgICB9KSkpKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTURYQ29udGVudDtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuZXhwb3J0IHsgTURYQ29udGVudCBhcyBkZWZhdWx0IH07IiwiZnVuY3Rpb24gX3RlbXBsYXRlT2JqZWN0KCkge1xuICB2YXIgZGF0YSA9IF90YWdnZWRUZW1wbGF0ZUxpdGVyYWwoW1wiXFxuICBjb2xvcjogYmxhY2s7XFxuICBcIiwgXCI7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIGZvbnQtc2l6ZTogMTBweDtcXG4gIGJvcmRlci1yYWRpdXM6IDNweDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkIGxpZ2h0Z3JleTtcXG4gIHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7XFxuICBcIiwgXCI7XFxuXCJdKTtcblxuICBfdGVtcGxhdGVPYmplY3QgPSBmdW5jdGlvbiBfdGVtcGxhdGVPYmplY3QoKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH07XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIF90YWdnZWRUZW1wbGF0ZUxpdGVyYWwoc3RyaW5ncywgcmF3KSB7IGlmICghcmF3KSB7IHJhdyA9IHN0cmluZ3Muc2xpY2UoMCk7IH0gcmV0dXJuIE9iamVjdC5mcmVlemUoT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoc3RyaW5ncywgeyByYXc6IHsgdmFsdWU6IE9iamVjdC5mcmVlemUocmF3KSB9IH0pKTsgfVxuXG5pbXBvcnQgc3R5bGVkIGZyb20gJ3N0eWxlZC1jb21wb25lbnRzJztcbmltcG9ydCB7IGZvbnRGYW1pbHksIHNwYWNlIH0gZnJvbSAnc3R5bGVkLXN5c3RlbSc7XG52YXIgRG9jTGFiZWwgPSBzdHlsZWQubGFiZWwoX3RlbXBsYXRlT2JqZWN0KCksIGZvbnRGYW1pbHksIHNwYWNlKTtcbkRvY0xhYmVsLmRlZmF1bHRQcm9wcyA9IHtcbiAgZm9udEZhbWlseTogJ2RlZmF1bHQnLFxuICBweDogMVxufTtcbmV4cG9ydCBkZWZhdWx0IERvY0xhYmVsOyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7IHZhciBrZXksIGk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgdmFyIGtleSwgaTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHsgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9OyByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfVxuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgTURYVGFnIH0gZnJvbSAnQG1keC1qcy90YWcnO1xuaW1wb3J0IHsgVG9vbHRpcCB9IGZyb20gJ2NhYmFuYS1yZWFjdCc7XG5pbXBvcnQgRG9jTGFiZWwgZnJvbSAnLi4vY29tcG9uZW50cy9Eb2NMYWJlbC5qcyc7XG52YXIgYmFzZVByb3BzID0ge1xuICBmb250RmFtaWx5OiAnZGVmYXVsdCcsXG4gIGNvbnRlbnQ6ICdIZXJlIGlzIG15IHRvb2x0aXAhJyxcbiAgYmc6ICdwcmltYXJ5JyxcbiAgY29sb3I6ICdwYXBheWF3aGlwJyxcbiAgbXg6IDIsXG4gIG15OiA4XG59O1xuXG52YXIgQmFzZVRvb2x0aXAgPSBmdW5jdGlvbiBCYXNlVG9vbHRpcChvdGhlclByb3BzKSB7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFRvb2x0aXAsIF9leHRlbmRzKHt9LCBiYXNlUHJvcHMsIG90aGVyUHJvcHMpKTtcbn07XG5cbnZhciBNRFhDb250ZW50ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhNRFhDb250ZW50LCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBNRFhDb250ZW50KHByb3BzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1EWENvbnRlbnQpO1xuXG4gICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoTURYQ29udGVudCkuY2FsbCh0aGlzLCBwcm9wcykpO1xuICAgIF90aGlzLmxheW91dCA9IG51bGw7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKE1EWENvbnRlbnQsIFt7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIGNvbXBvbmVudHMgPSBfdGhpcyRwcm9wcy5jb21wb25lbnRzLFxuICAgICAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF90aGlzJHByb3BzLCBbXCJjb21wb25lbnRzXCJdKTtcblxuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTURYVGFnLCB7XG4gICAgICAgIG5hbWU6IFwid3JhcHBlclwiLFxuICAgICAgICBjb21wb25lbnRzOiBjb21wb25lbnRzXG4gICAgICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KE1EWFRhZywge1xuICAgICAgICBuYW1lOiBcInBcIixcbiAgICAgICAgY29tcG9uZW50czogY29tcG9uZW50c1xuICAgICAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImFcIiwge1xuICAgICAgICBpZDogXCJUb29sdGlwXCJcbiAgICAgIH0pKSwgUmVhY3QuY3JlYXRlRWxlbWVudChNRFhUYWcsIHtcbiAgICAgICAgbmFtZTogXCJoMVwiLFxuICAgICAgICBjb21wb25lbnRzOiBjb21wb25lbnRzXG4gICAgICB9LCBcIlRvb2x0aXBcIiksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTURYVGFnLCB7XG4gICAgICAgIG5hbWU6IFwicFwiLFxuICAgICAgICBjb21wb25lbnRzOiBjb21wb25lbnRzXG4gICAgICB9LCBcIkhvdmVyIG92ZXIgdGhlIGxhYmVscyBiZWxvdyB0byBzZWUgdGhlIHRvb2x0aXBzLlwiKSwgUmVhY3QuY3JlYXRlRWxlbWVudChCYXNlVG9vbHRpcCwgbnVsbCwgUmVhY3QuY3JlYXRlRWxlbWVudChEb2NMYWJlbCwgbnVsbCwgXCJEZWZhdWx0XCIpKSwgUmVhY3QuY3JlYXRlRWxlbWVudChCYXNlVG9vbHRpcCwge1xuICAgICAgICBwbGFjZW1lbnQ6IFwidG9wXCIsXG4gICAgICAgIGJnOiBcIndhcm5pbmdcIixcbiAgICAgICAgY29sb3I6IFwic2Vjb25kYXJ5XCJcbiAgICAgIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRG9jTGFiZWwsIG51bGwsIFwiVG9wXCIpKSwgUmVhY3QuY3JlYXRlRWxlbWVudChCYXNlVG9vbHRpcCwge1xuICAgICAgICBwbGFjZW1lbnQ6IFwicmlnaHRcIlxuICAgICAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChEb2NMYWJlbCwgbnVsbCwgXCJSaWdodFwiKSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQmFzZVRvb2x0aXAsIHtcbiAgICAgICAgcGxhY2VtZW50OiBcImJvdHRvbVwiXG4gICAgICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KERvY0xhYmVsLCBudWxsLCBcIkJvdHRvbVwiKSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQmFzZVRvb2x0aXAsIHtcbiAgICAgICAgcGxhY2VtZW50OiBcImxlZnRcIlxuICAgICAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChEb2NMYWJlbCwgbnVsbCwgXCJMZWZ0XCIpKSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE1EWENvbnRlbnQ7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbmV4cG9ydCB7IE1EWENvbnRlbnQgYXMgZGVmYXVsdCB9OyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7IHZhciBrZXksIGk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgdmFyIGtleSwgaTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgTURYVGFnIH0gZnJvbSAnQG1keC1qcy90YWcnO1xuaW1wb3J0IHsgQ2hpcCB9IGZyb20gJ2NhYmFuYS1yZWFjdCc7XG5cbnZhciBNRFhDb250ZW50ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhNRFhDb250ZW50LCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBNRFhDb250ZW50KHByb3BzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1EWENvbnRlbnQpO1xuXG4gICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoTURYQ29udGVudCkuY2FsbCh0aGlzLCBwcm9wcykpO1xuICAgIF90aGlzLmxheW91dCA9IG51bGw7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKE1EWENvbnRlbnQsIFt7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIGNvbXBvbmVudHMgPSBfdGhpcyRwcm9wcy5jb21wb25lbnRzLFxuICAgICAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF90aGlzJHByb3BzLCBbXCJjb21wb25lbnRzXCJdKTtcblxuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTURYVGFnLCB7XG4gICAgICAgIG5hbWU6IFwid3JhcHBlclwiLFxuICAgICAgICBjb21wb25lbnRzOiBjb21wb25lbnRzXG4gICAgICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KE1EWFRhZywge1xuICAgICAgICBuYW1lOiBcInBcIixcbiAgICAgICAgY29tcG9uZW50czogY29tcG9uZW50c1xuICAgICAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImFcIiwge1xuICAgICAgICBpZDogXCJDaGlwc1wiXG4gICAgICB9KSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTURYVGFnLCB7XG4gICAgICAgIG5hbWU6IFwiaDFcIixcbiAgICAgICAgY29tcG9uZW50czogY29tcG9uZW50c1xuICAgICAgfSwgXCJDaGlwc1wiKSwgUmVhY3QuY3JlYXRlRWxlbWVudChDaGlwLCB7XG4gICAgICAgIG1yOiAxLFxuICAgICAgICB0ZXh0OiBcIkphY2sgV2hpdGVcIlxuICAgICAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ2hpcCwge1xuICAgICAgICBtcjogMSxcbiAgICAgICAgdGV4dDogXCJBZGVsZVwiLFxuICAgICAgICBkaXNtaXNzYWJsZTogdHJ1ZVxuICAgICAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ2hpcCwge1xuICAgICAgICBtcjogMSxcbiAgICAgICAgYmc6IFwic2Vjb25kYXJ5XCIsXG4gICAgICAgIHRleHQ6IFwiRnJlZGRpZSBNZXJjdXJ5XCIsXG4gICAgICAgIGRpc21pc3NhYmxlOiB0cnVlXG4gICAgICB9KSwgUmVhY3QuY3JlYXRlRWxlbWVudChDaGlwLCB7XG4gICAgICAgIG1yOiAxLFxuICAgICAgICBiZzogXCJ0ZXJ0aWFyeVwiLFxuICAgICAgICB0ZXh0OiBcIlRob20gWW9ya2VcIlxuICAgICAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ2hpcCwge1xuICAgICAgICBtcjogMSxcbiAgICAgICAgdGV4dDogXCJEdXJhbiBEdXJhblwiLFxuICAgICAgICBhdmF0YXJVcmw6IFwiaHR0cHM6Ly9pbWFnZXMucGV4ZWxzLmNvbS9waG90b3MvMTA5MjQzL3BleGVscy1waG90by0xMDkyNDMuanBlZz9hdXRvPWNvbXByZXNzJmNzPXRpbnlzcmdiJmRwcj0yJmg9NzUwJnc9MTI2MFwiXG4gICAgICB9KSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE1EWENvbnRlbnQ7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbmV4cG9ydCB7IE1EWENvbnRlbnQgYXMgZGVmYXVsdCB9OyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7IHZhciBrZXksIGk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7IGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9OyB2YXIgdGFyZ2V0ID0ge307IHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgdmFyIGtleSwgaTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgTURYVGFnIH0gZnJvbSAnQG1keC1qcy90YWcnO1xuaW1wb3J0IHsgVGFnIH0gZnJvbSAnY2FiYW5hLXJlYWN0JztcblxudmFyIE1EWENvbnRlbnQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKE1EWENvbnRlbnQsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIE1EWENvbnRlbnQocHJvcHMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTURYQ29udGVudCk7XG5cbiAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihNRFhDb250ZW50KS5jYWxsKHRoaXMsIHByb3BzKSk7XG4gICAgX3RoaXMubGF5b3V0ID0gbnVsbDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTURYQ29udGVudCwgW3tcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgY29tcG9uZW50cyA9IF90aGlzJHByb3BzLmNvbXBvbmVudHMsXG4gICAgICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3RoaXMkcHJvcHMsIFtcImNvbXBvbmVudHNcIl0pO1xuXG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChNRFhUYWcsIHtcbiAgICAgICAgbmFtZTogXCJ3cmFwcGVyXCIsXG4gICAgICAgIGNvbXBvbmVudHM6IGNvbXBvbmVudHNcbiAgICAgIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTURYVGFnLCB7XG4gICAgICAgIG5hbWU6IFwicFwiLFxuICAgICAgICBjb21wb25lbnRzOiBjb21wb25lbnRzXG4gICAgICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYVwiLCB7XG4gICAgICAgIGlkOiBcIlRhZ3NcIlxuICAgICAgfSkpLCBSZWFjdC5jcmVhdGVFbGVtZW50KE1EWFRhZywge1xuICAgICAgICBuYW1lOiBcImgxXCIsXG4gICAgICAgIGNvbXBvbmVudHM6IGNvbXBvbmVudHNcbiAgICAgIH0sIFwiVGFnc1wiKSwgUmVhY3QuY3JlYXRlRWxlbWVudChUYWcsIHtcbiAgICAgICAgbXI6IDEsXG4gICAgICAgIHRleHQ6IFwiSmFjayBXaGl0ZVwiXG4gICAgICB9KSwgUmVhY3QuY3JlYXRlRWxlbWVudChUYWcsIHtcbiAgICAgICAgbXI6IDEsXG4gICAgICAgIHRleHQ6IFwiQWRlbGVcIixcbiAgICAgICAgZGlzbWlzc2FibGU6IHRydWVcbiAgICAgIH0pLCBSZWFjdC5jcmVhdGVFbGVtZW50KFRhZywge1xuICAgICAgICBtcjogMSxcbiAgICAgICAgYmc6IFwic2Vjb25kYXJ5XCIsXG4gICAgICAgIHRleHQ6IFwiRnJlZGRpZSBNZXJjdXJ5XCIsXG4gICAgICAgIGRpc21pc3NhYmxlOiB0cnVlXG4gICAgICB9KSwgUmVhY3QuY3JlYXRlRWxlbWVudChUYWcsIHtcbiAgICAgICAgbXI6IDEsXG4gICAgICAgIGJnOiBcInRlcnRpYXJ5XCIsXG4gICAgICAgIHRleHQ6IFwiVGhvbSBZb3JrZVwiXG4gICAgICB9KSwgUmVhY3QuY3JlYXRlRWxlbWVudChUYWcsIHtcbiAgICAgICAgbXI6IDEsXG4gICAgICAgIHRleHQ6IFwiRHVyYW4gRHVyYW5cIixcbiAgICAgICAgYXZhdGFyVXJsOiBcImh0dHBzOi8vaW1hZ2VzLnBleGVscy5jb20vcGhvdG9zLzEwOTI0My9wZXhlbHMtcGhvdG8tMTA5MjQzLmpwZWc/YXV0bz1jb21wcmVzcyZjcz10aW55c3JnYiZkcHI9MiZoPTc1MCZ3PTEyNjBcIlxuICAgICAgfSkpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBNRFhDb250ZW50O1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5leHBvcnQgeyBNRFhDb250ZW50IGFzIGRlZmF1bHQgfTsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IE1EWFRhZyB9IGZyb20gJ0BtZHgtanMvdGFnJztcbmltcG9ydCB7IEF2YXRhciB9IGZyb20gJ2NhYmFuYS1yZWFjdCc7XG5pbXBvcnQgRG9jTGFiZWwgZnJvbSAnLi4vY29tcG9uZW50cy9Eb2NMYWJlbCc7XG52YXIgZGVtb1NyYyA9ICdodHRwczovL2ltYWdlcy5wZXhlbHMuY29tL3Bob3Rvcy8xMDkyNDMvcGV4ZWxzLXBob3RvLTEwOTI0My5qcGVnP2F1dG89Y29tcHJlc3MmY3M9dGlueXNyZ2ImZHByPTImaD03NTAmdz0xMjYwJztcblxudmFyIExhYmVsID0gZnVuY3Rpb24gTGFiZWwocHJvcHMpIHtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRG9jTGFiZWwsIF9leHRlbmRzKHtcbiAgICBtcjogMSxcbiAgICBtdDogMlxuICB9LCBwcm9wcykpO1xufTtcblxudmFyIE1EWENvbnRlbnQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKE1EWENvbnRlbnQsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIE1EWENvbnRlbnQocHJvcHMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTURYQ29udGVudCk7XG5cbiAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihNRFhDb250ZW50KS5jYWxsKHRoaXMsIHByb3BzKSk7XG4gICAgX3RoaXMubGF5b3V0ID0gbnVsbDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTURYQ29udGVudCwgW3tcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgY29tcG9uZW50cyA9IF90aGlzJHByb3BzLmNvbXBvbmVudHMsXG4gICAgICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3RoaXMkcHJvcHMsIFtcImNvbXBvbmVudHNcIl0pO1xuXG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChNRFhUYWcsIHtcbiAgICAgICAgbmFtZTogXCJ3cmFwcGVyXCIsXG4gICAgICAgIGNvbXBvbmVudHM6IGNvbXBvbmVudHNcbiAgICAgIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTURYVGFnLCB7XG4gICAgICAgIG5hbWU6IFwicFwiLFxuICAgICAgICBjb21wb25lbnRzOiBjb21wb25lbnRzXG4gICAgICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYVwiLCB7XG4gICAgICAgIGlkOiBcIkF2YXRhcnNcIlxuICAgICAgfSkpLCBSZWFjdC5jcmVhdGVFbGVtZW50KE1EWFRhZywge1xuICAgICAgICBuYW1lOiBcImgxXCIsXG4gICAgICAgIGNvbXBvbmVudHM6IGNvbXBvbmVudHNcbiAgICAgIH0sIFwiQXZhdGFyc1wiKSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgICAgIGFsaWduSXRlbXM6ICdmbGV4LWVuZCdcbiAgICAgICAgfVxuICAgICAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBudWxsLCBSZWFjdC5jcmVhdGVFbGVtZW50KEF2YXRhciwge1xuICAgICAgICBteDogMixcbiAgICAgICAgc2l6ZTogXCJqdW1ib1wiLFxuICAgICAgICBzcmM6IGRlbW9TcmNcbiAgICAgIH0pLCBSZWFjdC5jcmVhdGVFbGVtZW50KExhYmVsLCBudWxsLCBcIkp1bWJvXCIpKSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBudWxsLCBSZWFjdC5jcmVhdGVFbGVtZW50KEF2YXRhciwge1xuICAgICAgICBteDogMixcbiAgICAgICAgc2l6ZTogXCJsYXJnZVwiLFxuICAgICAgICBzcmM6IGRlbW9TcmNcbiAgICAgIH0pLCBSZWFjdC5jcmVhdGVFbGVtZW50KExhYmVsLCBudWxsLCBcIkxhcmdlXCIpKSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBudWxsLCBSZWFjdC5jcmVhdGVFbGVtZW50KEF2YXRhciwge1xuICAgICAgICBteDogMixcbiAgICAgICAgc2l6ZTogXCJtZWRpdW1cIixcbiAgICAgICAgc3JjOiBkZW1vU3JjXG4gICAgICB9KSwgUmVhY3QuY3JlYXRlRWxlbWVudChMYWJlbCwgbnVsbCwgXCJNZWRpdW1cIikpLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIG51bGwsIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQXZhdGFyLCB7XG4gICAgICAgIG14OiAyLFxuICAgICAgICBzaXplOiBcInNtYWxsXCIsXG4gICAgICAgIHNyYzogZGVtb1NyY1xuICAgICAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTGFiZWwsIG51bGwsIFwiU21hbGxcIikpKSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE1EWENvbnRlbnQ7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbmV4cG9ydCB7IE1EWENvbnRlbnQgYXMgZGVmYXVsdCB9OyIsImZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBCb3gsIEhlYWRpbmdPbmUsIEhlYWRpbmdUaHJlZSwgSGVhZGluZ0ZpdmUsIEJvZHlUZXh0IH0gZnJvbSAnY2FiYW5hLXJlYWN0JztcbmltcG9ydCBCdXR0b24gZnJvbSAnLi4vZG9jcy9CdXR0b24ubWR4JztcbmltcG9ydCBDYXJkIGZyb20gJy4uL2RvY3MvQ2FyZC5tZHgnO1xuaW1wb3J0IEZvcm1zIGZyb20gJy4uL2RvY3MvRm9ybXMvaW5kZXgubWR4JztcbmltcG9ydCBJY29uIGZyb20gJy4uL2RvY3MvSWNvbi5tZHgnO1xuaW1wb3J0IERvY3NOYXYgZnJvbSAnLi4vY29tcG9uZW50cy9Eb2NzTmF2JztcbmltcG9ydCBOb3RpZmljYXRpb25CYXIgZnJvbSAnLi4vZG9jcy9Ob3RpZmljYXRpb25CYXIubWR4JztcbmltcG9ydCBQYWdpbmF0aW9uIGZyb20gJy4uL2RvY3MvUGFnaW5hdGlvbi5tZHgnO1xuaW1wb3J0IFByb2dyZXNzQmFyIGZyb20gJy4uL2RvY3MvUHJvZ3Jlc3NCYXIvaW5kZXgubWR4JztcbmltcG9ydCBUYWJzIGZyb20gJy4uL2RvY3MvVGFicy5tZHgnO1xuaW1wb3J0IFRleHQgZnJvbSAnLi4vZG9jcy9UZXh0Lm1keCc7XG5pbXBvcnQgVG9vbHRpcCBmcm9tICcuLi9kb2NzL1Rvb2x0aXAubWR4JztcbmltcG9ydCBDaGlwIGZyb20gJy4uL2RvY3MvQ2hpcC5tZHgnO1xuaW1wb3J0IFRhZ3MgZnJvbSAnLi4vZG9jcy9UYWdzLm1keCc7XG5pbXBvcnQgQXZhdGFycyBmcm9tICcuLi9kb2NzL0F2YXRhcnMubWR4JztcbmltcG9ydCB7IE1EWFByb3ZpZGVyIH0gZnJvbSAnQG1keC1qcy90YWcnO1xuXG52YXIgSDEgPSBmdW5jdGlvbiBIMShwcm9wcykge1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChIZWFkaW5nVGhyZWUsIF9leHRlbmRzKHtcbiAgICBpczogXCJoMVwiLFxuICAgIHB0OiAxMixcbiAgICBtYjogMixcbiAgICBzdHlsZToge1xuICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcbiAgICAgIGJvcmRlckJvdHRvbTogJzFweCBzb2xpZCBsaWdodGdyZXknXG4gICAgfVxuICB9LCBwcm9wcykpO1xufTtcblxudmFyIEgyID0gZnVuY3Rpb24gSDIocHJvcHMpIHtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSGVhZGluZ0ZpdmUsIF9leHRlbmRzKHtcbiAgICBpczogXCJoMlwiLFxuICAgIG15OiAyXG4gIH0sIHByb3BzKSk7XG59O1xuXG52YXIgRG9jc1RleHQgPSBmdW5jdGlvbiBEb2NzVGV4dChwcm9wcykge1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChCb2R5VGV4dCwgX2V4dGVuZHMoe1xuICAgIHBiOiAyXG4gIH0sIHByb3BzKSk7XG59O1xuXG52YXIgY29tcG9uZW50cyA9IHtcbiAgaDE6IEgxLFxuICBoMjogSDIsXG4gIHA6IERvY3NUZXh0IC8vICAgLy8gLi4uXG4gIC8vICAgY29kZTogUHJlLFxuICAvLyAgIGlubGluZUNvZGU6IENvZGVcblxufTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFN0eWxlR3VpZGUoKSB7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KE1EWFByb3ZpZGVyLCB7XG4gICAgY29tcG9uZW50czogY29tcG9uZW50c1xuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KEJveCwge1xuICAgIGRpc3BsYXk6IFwiZmxleFwiXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRG9jc05hdiwgbnVsbCksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQm94LCB7XG4gICAgbWw6IDI0NixcbiAgICBtYXhXaWR0aDogMTAwMCxcbiAgICBweDogNFxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KEhlYWRpbmdPbmUsIHtcbiAgICBtdDogM1xuICB9LCBcIkNvbXBvbmVudCBMaWJyYXJ5XCIpLCBSZWFjdC5jcmVhdGVFbGVtZW50KEF2YXRhcnMsIG51bGwpLCBSZWFjdC5jcmVhdGVFbGVtZW50KEJ1dHRvbiwgbnVsbCksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ2FyZCwgbnVsbCksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ2hpcCwgbnVsbCksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRm9ybXMsIG51bGwpLCBSZWFjdC5jcmVhdGVFbGVtZW50KEljb24sIG51bGwpLCBSZWFjdC5jcmVhdGVFbGVtZW50KE5vdGlmaWNhdGlvbkJhciwgbnVsbCksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUGFnaW5hdGlvbiwgbnVsbCksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUHJvZ3Jlc3NCYXIsIG51bGwpLCBSZWFjdC5jcmVhdGVFbGVtZW50KFRhYnMsIG51bGwpLCBSZWFjdC5jcmVhdGVFbGVtZW50KFRhZ3MsIG51bGwpLCBSZWFjdC5jcmVhdGVFbGVtZW50KFRleHQsIG51bGwpLCBSZWFjdC5jcmVhdGVFbGVtZW50KFRvb2x0aXAsIG51bGwpKSkpO1xufSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDckdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDMUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMzSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDOUZBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM3RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqR0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///479\n')}}]);